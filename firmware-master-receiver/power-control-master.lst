   1               		.file	"power-control-master.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 104               	.global	writeSPI
 106               	writeSPI:
 107               		.stabd	46,0,0
 109               	.Ltext1:
   1:../libs-master-receiver/rfm01.c **** /**
   2:../libs-master-receiver/rfm01.c **** @mainpage Power Control Project Master Unit
   3:../libs-master-receiver/rfm01.c **** @version 0.0.0
   4:../libs-master-receiver/rfm01.c **** @author Ken Sarkies (www.jiggerjuice.net)
   5:../libs-master-receiver/rfm01.c **** @date 11 October 2014
   6:../libs-master-receiver/rfm01.c **** @brief Llibrary for the RFM01 Receiver
   7:../libs-master-receiver/rfm01.c **** 
   8:../libs-master-receiver/rfm01.c **** @note
   9:../libs-master-receiver/rfm01.c **** Software: AVR-GCC 4.8.2
  10:../libs-master-receiver/rfm01.c **** @note
  11:../libs-master-receiver/rfm01.c **** Target:   Any AVR with sufficient output ports and a timer
  12:../libs-master-receiver/rfm01.c **** @note
  13:../libs-master-receiver/rfm01.c **** Tested:   ATMega48 at 8MHz internal clock.
  14:../libs-master-receiver/rfm01.c **** 
  15:../libs-master-receiver/rfm01.c **** This library implements the software SPI interface between the AVR and the
  16:../libs-master-receiver/rfm01.c **** HopeRF RFM01 receiver module.
  17:../libs-master-receiver/rfm01.c **** 
  18:../libs-master-receiver/rfm01.c **** This file needs to be included in the main source following the parameter
  19:../libs-master-receiver/rfm01.c **** definitions (normally placed in the header file) and the AVR pin definitions
  20:../libs-master-receiver/rfm01.c **** for the software SPI and the RFM01 control pins.
  21:../libs-master-receiver/rfm01.c ****  */
  22:../libs-master-receiver/rfm01.c **** /***************************************************************************
  23:../libs-master-receiver/rfm01.c ****  *   Copyright (C) 2011 by Ken Sarkies                                     *
  24:../libs-master-receiver/rfm01.c ****  *   ksarkies@internode.on.net                                             *
  25:../libs-master-receiver/rfm01.c ****  *                                                                         *
  26:../libs-master-receiver/rfm01.c ****  *   This file is part of Power Controller                                 *
  27:../libs-master-receiver/rfm01.c ****  *                                                                         *
  28:../libs-master-receiver/rfm01.c ****  *   This is free software; you can redistribute it and/or modify          *
  29:../libs-master-receiver/rfm01.c ****  *   it under the terms of the GNU General Public License as published by  *
  30:../libs-master-receiver/rfm01.c ****  *   the Free Software Foundation; either version 2 of the License, or     *
  31:../libs-master-receiver/rfm01.c ****  *   (at your option) any later version.                                   *
  32:../libs-master-receiver/rfm01.c ****  *                                                                         *
  33:../libs-master-receiver/rfm01.c ****  *   This software is distributed in the hope that it will be useful,      *
  34:../libs-master-receiver/rfm01.c ****  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  35:../libs-master-receiver/rfm01.c ****  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  36:../libs-master-receiver/rfm01.c ****  *   GNU General Public License for more details.                          *
  37:../libs-master-receiver/rfm01.c ****  *                                                                         *
  38:../libs-master-receiver/rfm01.c ****  *   You should have received a copy of the GNU General Public License     *
  39:../libs-master-receiver/rfm01.c ****  *   along with the software. If not, write to the:                        *
  40:../libs-master-receiver/rfm01.c ****  *   Free Software Foundation, Inc.,                                       *
  41:../libs-master-receiver/rfm01.c ****  *   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA.             *
  42:../libs-master-receiver/rfm01.c ****  ***************************************************************************/
  43:../libs-master-receiver/rfm01.c **** 
  44:../libs-master-receiver/rfm01.c **** /** Convenience macros (we don't use them all) */
  45:../libs-master-receiver/rfm01.c **** #define TRUE 1
  46:../libs-master-receiver/rfm01.c **** #define FALSE 0
  47:../libs-master-receiver/rfm01.c **** 
  48:../libs-master-receiver/rfm01.c **** #define inb(sfr) _SFR_BYTE(sfr)
  49:../libs-master-receiver/rfm01.c **** #define inw(sfr) _SFR_WORD(sfr)
  50:../libs-master-receiver/rfm01.c **** #define outb(sfr, val) (_SFR_BYTE(sfr) = (val))
  51:../libs-master-receiver/rfm01.c **** #define outw(sfr, val) (_SFR_WORD(sfr) = (val))
  52:../libs-master-receiver/rfm01.c **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  53:../libs-master-receiver/rfm01.c **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  54:../libs-master-receiver/rfm01.c **** #define high(x) ((uint8_t) (x >> 8) & 0xFF)
  55:../libs-master-receiver/rfm01.c **** #define low(x) ((uint8_t) (x & 0xFF))
  56:../libs-master-receiver/rfm01.c **** 
  57:../libs-master-receiver/rfm01.c **** /** SPI Clock Timing */
  58:../libs-master-receiver/rfm01.c **** #define SPI_DELAY 1
  59:../libs-master-receiver/rfm01.c **** 
  60:../libs-master-receiver/rfm01.c **** /*****************************************************************************/
  61:../libs-master-receiver/rfm01.c **** /* Global Variables */
  62:../libs-master-receiver/rfm01.c **** 
  63:../libs-master-receiver/rfm01.c **** uint16_t lastRfm01Status = 0;
  64:../libs-master-receiver/rfm01.c **** 
  65:../libs-master-receiver/rfm01.c **** /****************************************************************************/
  66:../libs-master-receiver/rfm01.c **** /** @brief Set the Configuration of the Transmitter for RFM01.
  67:../libs-master-receiver/rfm01.c **** 
  68:../libs-master-receiver/rfm01.c **** Not all parameters are configurable. The wakeup timer, low battery and the
  69:../libs-master-receiver/rfm01.c **** clock out are disabled. The transmitter chain is powered off.
  70:../libs-master-receiver/rfm01.c **** */
  71:../libs-master-receiver/rfm01.c **** void receiverConfigure()
  72:../libs-master-receiver/rfm01.c **** {
  73:../libs-master-receiver/rfm01.c ****     _delay_ms(150);
  74:../libs-master-receiver/rfm01.c **** 	writeCMD(CONFIGURATION, 16);    /* Configure command */
  75:../libs-master-receiver/rfm01.c **** /* Set the low battery threshold and the microprocessor clock output */
  76:../libs-master-receiver/rfm01.c **** 	writeCMD(BATTERY, 16);
  77:../libs-master-receiver/rfm01.c **** 	writeCMD(FREQUENCY, 16);        /* Set carrier frequency */
  78:../libs-master-receiver/rfm01.c **** /* Receiver Setting Command, disable the receiver chain */
  79:../libs-master-receiver/rfm01.c **** 	writeCMD(RECEIVER, 16);
  80:../libs-master-receiver/rfm01.c **** /* Receiver Setting Command, enable the entire receiver chain */
  81:../libs-master-receiver/rfm01.c **** 	writeCMD(RECEIVER | _BV(0), 16);
  82:../libs-master-receiver/rfm01.c **** /* Set the FIFO options */
  83:../libs-master-receiver/rfm01.c **** 	resetFIFO();
  84:../libs-master-receiver/rfm01.c **** /* Set the Baseband Data Filter and Clock Recovery options */
  85:../libs-master-receiver/rfm01.c **** 	writeCMD(BASEFILTER, 16);
  86:../libs-master-receiver/rfm01.c **** /* Set the expected data bitrate */
  87:../libs-master-receiver/rfm01.c **** 	writeCMD(DATARATE, 16);
  88:../libs-master-receiver/rfm01.c **** /* Set the AFC enable pattern, range limits and measurement mode */
  89:../libs-master-receiver/rfm01.c **** 	writeCMD(AFC, 16);
  90:../libs-master-receiver/rfm01.c **** }
  91:../libs-master-receiver/rfm01.c **** 
  92:../libs-master-receiver/rfm01.c **** /****************************************************************************/
  93:../libs-master-receiver/rfm01.c **** /** @brief Reset the FIFO
  94:../libs-master-receiver/rfm01.c **** 
  95:../libs-master-receiver/rfm01.c **** Clearing bit 1 of the FIFO command will clear the FIFO and restart the synchron
  96:../libs-master-receiver/rfm01.c **** word detection. Set it to restart the FIFO counter.
  97:../libs-master-receiver/rfm01.c **** */
  98:../libs-master-receiver/rfm01.c **** void resetFIFO(void)
  99:../libs-master-receiver/rfm01.c **** {
 100:../libs-master-receiver/rfm01.c ****     writeCMD(FIFO, 16);
 101:../libs-master-receiver/rfm01.c **** 	writeCMD(FIFO | _BV(1), 16);
 102:../libs-master-receiver/rfm01.c **** }
 103:../libs-master-receiver/rfm01.c **** 
 104:../libs-master-receiver/rfm01.c **** /****************************************************************************/
 105:../libs-master-receiver/rfm01.c **** /** @brief Write a Command to the RFM01 over SPI
 106:../libs-master-receiver/rfm01.c ****   
 107:../libs-master-receiver/rfm01.c **** A command is clocked out to the RFM01 one bit at a time.
 108:../libs-master-receiver/rfm01.c **** All RF01 commands are 16 bit but the second parameter is kept for code
 109:../libs-master-receiver/rfm01.c **** compatibility with the other RF chips.
 110:../libs-master-receiver/rfm01.c **** At the same time a result is clocked back in one bit at a time. The result
 111:../libs-master-receiver/rfm01.c **** is returned as a 16 bit word.
 112:../libs-master-receiver/rfm01.c **** 
 113:../libs-master-receiver/rfm01.c **** Each bit of output status is available before the clock pulse. After
 114:../libs-master-receiver/rfm01.c **** the last clock pulse the first FIFO data is presented.
 115:../libs-master-receiver/rfm01.c **** 
 116:../libs-master-receiver/rfm01.c **** For the RFM01 receiver module the returned result is meaningless except
 117:../libs-master-receiver/rfm01.c **** for the status read command which is 16 bits.
 118:../libs-master-receiver/rfm01.c **** 
 119:../libs-master-receiver/rfm01.c **** Parameter:  16 or 8 bit command
 120:../libs-master-receiver/rfm01.c **** Parameter:  length of command (8 or 16)
 121:../libs-master-receiver/rfm01.c **** Return:     Value returned from the SPI interface 
 122:../libs-master-receiver/rfm01.c **** */
 123:../libs-master-receiver/rfm01.c **** uint16_t writeCMD(uint16_t command, uint8_t n)
 124:../libs-master-receiver/rfm01.c **** {
 125:../libs-master-receiver/rfm01.c **** 	if (n < 16)                                 /* For 8 bit commands */
 126:../libs-master-receiver/rfm01.c ****         command <<= (16-n);                     /* Shift command byte to upper byte */
 127:../libs-master-receiver/rfm01.c **** 	uint16_t result = 0;						/* Holds the received SDI */
 128:../libs-master-receiver/rfm01.c **** 	cbi(CS_PORT,nSEL);	                        /* Set CS LOW */
 129:../libs-master-receiver/rfm01.c **** 	while(n--)									/* Send All Bits MSB First */
 130:../libs-master-receiver/rfm01.c **** 	{
 131:../libs-master-receiver/rfm01.c **** 		result <<= 1;                           /* Shift left for next bit to receive */
 132:../libs-master-receiver/rfm01.c **** 		result |= ((inb(SPI_PIN) >> SDO) & 1);  /* add received bit to result */
 133:../libs-master-receiver/rfm01.c **** 		if (command & 0x8000)
 134:../libs-master-receiver/rfm01.c **** 			writeSPI(1);						/* Write 1 via SDI */
 135:../libs-master-receiver/rfm01.c **** 		else
 136:../libs-master-receiver/rfm01.c **** 			writeSPI(0);						/* Write 0 via SDI */
 137:../libs-master-receiver/rfm01.c **** 		command <<= 1;							/* Shift left for next bit to send */
 138:../libs-master-receiver/rfm01.c **** 	}
 139:../libs-master-receiver/rfm01.c **** 	sbi(CS_PORT,nSEL);							/* CS HIGH - Finished Sending Command */
 140:../libs-master-receiver/rfm01.c ****     return result;
 141:../libs-master-receiver/rfm01.c **** }
 142:../libs-master-receiver/rfm01.c **** 
 143:../libs-master-receiver/rfm01.c **** /****************************************************************************/
 144:../libs-master-receiver/rfm01.c **** /** @brief Read a Data Byte from the RFM01 FIFO over SPI
 145:../libs-master-receiver/rfm01.c ****   
 146:../libs-master-receiver/rfm01.c **** The RF01 has two modes of reading the FIFO. If the FIFO level is set to 1 then
 147:../libs-master-receiver/rfm01.c **** FIFO data available is read out from a dedicated pin, and the FIFO bit(s) can be
 148:../libs-master-receiver/rfm01.c **** read from the SDO pin. Alternatively a status read bit 1 will indicate the FIFO
 149:../libs-master-receiver/rfm01.c **** threshold exceeded and data can be read out following the remainder of the status
 150:../libs-master-receiver/rfm01.c **** word. The latter mode is used here to allow bytewise reception.
 151:../libs-master-receiver/rfm01.c **** 
 152:../libs-master-receiver/rfm01.c **** A status command (all zeros) is sent to the RFM01 to initiate a databyte read.
 153:../libs-master-receiver/rfm01.c **** The first 16 bits read out are status bits, followed by some data bits.
 154:../libs-master-receiver/rfm01.c **** When the FIFO fills to the trigger point FIFO_TRIGGER, the top status bit
 155:../libs-master-receiver/rfm01.c **** (first one transmitted) of the status word is set and can be tested.
 156:../libs-master-receiver/rfm01.c **** 
 157:../libs-master-receiver/rfm01.c **** The data is available before the SCK pulse, and is read first.
 158:../libs-master-receiver/rfm01.c **** 
 159:../libs-master-receiver/rfm01.c **** Normally FIFO_TRIGGER should be 8 to retrieve a single byte. It should not be
 160:../libs-master-receiver/rfm01.c **** close to 16 which is the maximum limit of the FIFO buffer. If FIFO_TRIGGER
 161:../libs-master-receiver/rfm01.c **** is less than 8 then only FIFO_TRIGGER bits are retrieved.
 162:../libs-master-receiver/rfm01.c **** 
 163:../libs-master-receiver/rfm01.c **** Data is read MSB first.
 164:../libs-master-receiver/rfm01.c **** 
 165:../libs-master-receiver/rfm01.c **** Return:     Full status word if no data ready, or received data byte in lower byte
 166:../libs-master-receiver/rfm01.c ****             along with upper byte of status word.
 167:../libs-master-receiver/rfm01.c **** */
 168:../libs-master-receiver/rfm01.c **** uint16_t readDataByte()
 169:../libs-master-receiver/rfm01.c **** {
 170:../libs-master-receiver/rfm01.c **** 	uint8_t n = 16;
 171:../libs-master-receiver/rfm01.c **** 	uint16_t rfm01Status = 0;	     			/* Holds the RF01 status word */
 172:../libs-master-receiver/rfm01.c **** 	uint16_t result = 0;						/* Holds the received data and status */
 173:../libs-master-receiver/rfm01.c **** 	cbi(CS_PORT,nSEL);	                        /* Set CS LOW */
 174:../libs-master-receiver/rfm01.c **** 	while(n--)                                  /* Start reading in the status word */
 175:../libs-master-receiver/rfm01.c **** 	{
 176:../libs-master-receiver/rfm01.c **** 		rfm01Status <<= 1;                       /* Shift left for next bit received */
 177:../libs-master-receiver/rfm01.c **** 		rfm01Status |= ((inb(SPI_PIN) >> SDO) & 1);  /* add received bit to status */
 178:../libs-master-receiver/rfm01.c **** 		writeSPI(0);						    /* Write 0 via SPI for status command */
 179:../libs-master-receiver/rfm01.c **** 	}
 180:../libs-master-receiver/rfm01.c ****     lastRfm01Status = rfm01Status;
 181:../libs-master-receiver/rfm01.c ****     if ((rfm01Status & 0x8000) != 0)             /* Check if FFIT is activated */
 182:../libs-master-receiver/rfm01.c ****     {
 183:../libs-master-receiver/rfm01.c ****         n = FIFO_TRIGGER;
 184:../libs-master-receiver/rfm01.c ****         if (n > 8) n = 8;                       /* Limit number read to a byte */
 185:../libs-master-receiver/rfm01.c **** 	    while(n--)						        /* Continue to send zeros to get data */
 186:../libs-master-receiver/rfm01.c **** 	    {
 187:../libs-master-receiver/rfm01.c **** 		    result <<= 1;                       /* Shift left for next bit received */
 188:../libs-master-receiver/rfm01.c **** 		    result |= ((inb(SPI_PIN) >> SDO) & 1);  /* add received bit to result */
 189:../libs-master-receiver/rfm01.c **** 		    writeSPI(0);						/* Write 0 via SPI for status command */
 190:../libs-master-receiver/rfm01.c **** 	    }
 191:../libs-master-receiver/rfm01.c ****         result |= (rfm01Status & 0xFF00);        /* return upper byte of status word with result */
 192:../libs-master-receiver/rfm01.c ****     }
 193:../libs-master-receiver/rfm01.c ****     else result = rfm01Status;                   /* may as well send something back */
 194:../libs-master-receiver/rfm01.c ****     sbi(CS_PORT,nSEL);					        /* CS high - finished sending status Command */
 195:../libs-master-receiver/rfm01.c ****     return result;
 196:../libs-master-receiver/rfm01.c **** }
 197:../libs-master-receiver/rfm01.c **** 
 198:../libs-master-receiver/rfm01.c **** /****************************************************************************/
 199:../libs-master-receiver/rfm01.c **** /** @brief Bitbang the data on the SPI
 200:../libs-master-receiver/rfm01.c **** 
 201:../libs-master-receiver/rfm01.c **** Data is setup and a delay is inserted to ensure that the rate is less than 25%
 202:../libs-master-receiver/rfm01.c **** of the clock, as required by the chip. The SCK is strobed high then low after
 203:../libs-master-receiver/rfm01.c **** delays. The function exits with SCK low. The datarate is kept to 250kbps to
 204:../libs-master-receiver/rfm01.c **** cope with a 1MHz clock on the chip at startup.
 205:../libs-master-receiver/rfm01.c **** 
 206:../libs-master-receiver/rfm01.c **** Parameter:  bit data sent, 0 or 1
 207:../libs-master-receiver/rfm01.c **** */
 208:../libs-master-receiver/rfm01.c **** 
 209:../libs-master-receiver/rfm01.c **** void writeSPI(uint8_t n)
 210:../libs-master-receiver/rfm01.c **** {
 111               	.LM0:
 112               	.LFBB1:
 113               	/* prologue: function */
 114               	/* frame size = 0 */
 115               	/* stack size = 0 */
 116               	.L__stack_usage = 0
 211:../libs-master-receiver/rfm01.c **** 	cbi(SPI_PORT,SCK);                          /* Clear the SCK */
 118               	.LM1:
 119 0000 5D98      		cbi 0xb,5
 120               	.LBB19:
 121               	.LBB20:
 123               	.Ltext2:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/avr/include/util/delay.h **** 
 166:/usr/lib/avr/include/util/delay.h **** #else
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/avr/include/util/delay.h **** 
 235:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/avr/include/util/delay.h **** 
 238:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h **** 	#else
 242:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/avr/include/util/delay.h **** 	#endif
 245:/usr/lib/avr/include/util/delay.h **** 
 246:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 125               	.LM2:
 126 0002 92E0      		ldi r25,lo8(2)
 127 0004 9A95      		1: dec r25
 128 0006 01F4      		brne 1b
 129 0008 00C0      		rjmp .
 130               	.LBE20:
 131               	.LBE19:
 133               	.Ltext3:
 212:../libs-master-receiver/rfm01.c ****     _delay_us(SPI_DELAY);                       /* delay to reduce rate to 250kbps */
 213:../libs-master-receiver/rfm01.c **** 	if (n) sbi(SPI_PORT,SDI);                   /* Setup data for strobe */
 135               	.LM3:
 136 000a 8111      		cpse r24,__zero_reg__
 137 000c 00C0      		rjmp .L5
 214:../libs-master-receiver/rfm01.c ****     else cbi(SPI_PORT,SDI);
 139               	.LM4:
 140 000e 5F98      		cbi 0xb,7
 141               	.L3:
 142               	.LBB21:
 143               	.LBB22:
 145               	.Ltext4:
 147               	.LM5:
 148 0010 82E0      		ldi r24,lo8(2)
 149 0012 8A95      		1: dec r24
 150 0014 01F4      		brne 1b
 151 0016 00C0      		rjmp .
 152               	.LBE22:
 153               	.LBE21:
 155               	.Ltext5:
 215:../libs-master-receiver/rfm01.c ****     _delay_us(SPI_DELAY);                       /* delay to reduce rate to 250kbps */
 216:../libs-master-receiver/rfm01.c **** 	sbi(SPI_PORT,SCK);                          /* Set the SCK to latch the data */
 157               	.LM6:
 158 0018 5D9A      		sbi 0xb,5
 159               	.LBB23:
 160               	.LBB24:
 162               	.Ltext6:
 164               	.LM7:
 165 001a 92E0      		ldi r25,lo8(2)
 166 001c 9A95      		1: dec r25
 167 001e 01F4      		brne 1b
 168 0020 00C0      		rjmp .
 169               	.LBE24:
 170               	.LBE23:
 172               	.Ltext7:
 217:../libs-master-receiver/rfm01.c ****     _delay_us(SPI_DELAY);                       /* delay to reduce rate to 250kbps */
 218:../libs-master-receiver/rfm01.c **** 	cbi(SPI_PORT,SCK);                          /* Clear the SCK */
 174               	.LM8:
 175 0022 5D98      		cbi 0xb,5
 176               	.LBB25:
 177               	.LBB26:
 179               	.Ltext8:
 181               	.LM9:
 182 0024 82E0      		ldi r24,lo8(2)
 183 0026 8A95      		1: dec r24
 184 0028 01F4      		brne 1b
 185 002a 00C0      		rjmp .
 186 002c 0895      		ret
 187               	.L5:
 188               	.LBE26:
 189               	.LBE25:
 191               	.Ltext9:
 213:../libs-master-receiver/rfm01.c **** 	if (n) sbi(SPI_PORT,SDI);                   /* Setup data for strobe */
 193               	.LM10:
 194 002e 5F9A      		sbi 0xb,7
 195 0030 00C0      		rjmp .L3
 197               	.Lscope1:
 199               		.stabd	78,0,0
 203               	.global	writeCMD
 205               	writeCMD:
 206               		.stabd	46,0,0
 124:../libs-master-receiver/rfm01.c **** {
 208               	.LM11:
 209               	.LFBB2:
 210 0032 FF92      		push r15
 211 0034 0F93      		push r16
 212 0036 1F93      		push r17
 213 0038 CF93      		push r28
 214 003a DF93      		push r29
 215               	/* prologue: function */
 216               	/* frame size = 0 */
 217               	/* stack size = 5 */
 218               	.L__stack_usage = 5
 219 003c 8C01      		movw r16,r24
 125:../libs-master-receiver/rfm01.c **** 	if (n < 16)                                 /* For 8 bit commands */
 221               	.LM12:
 222 003e 6031      		cpi r22,lo8(16)
 223 0040 00F4      		brsh .L7
 126:../libs-master-receiver/rfm01.c ****         command <<= (16-n);                     /* Shift command byte to upper byte */
 225               	.LM13:
 226 0042 80E1      		ldi r24,lo8(16)
 227 0044 90E0      		ldi r25,0
 228 0046 861B      		sub r24,r22
 229 0048 9109      		sbc r25,__zero_reg__
 230 004a 00C0      		rjmp 2f
 231               		1:
 232 004c 000F      		lsl r16
 233 004e 111F      		rol r17
 234               		2:
 235 0050 8A95      		dec r24
 236 0052 02F4      		brpl 1b
 128:../libs-master-receiver/rfm01.c **** 	cbi(CS_PORT,nSEL);	                        /* Set CS LOW */
 238               	.LM14:
 239 0054 5C98      		cbi 0xb,4
 129:../libs-master-receiver/rfm01.c **** 	while(n--)									/* Send All Bits MSB First */
 241               	.LM15:
 242 0056 6623      		tst r22
 243 0058 01F0      		breq .L13
 244               	.L12:
 124:../libs-master-receiver/rfm01.c **** {
 246               	.LM16:
 247 005a F62E      		mov r15,r22
 127:../libs-master-receiver/rfm01.c **** 	uint16_t result = 0;						/* Holds the received SDI */
 249               	.LM17:
 250 005c C0E0      		ldi r28,0
 251 005e D0E0      		ldi r29,0
 252 0060 00C0      		rjmp .L11
 253               	.L9:
 136:../libs-master-receiver/rfm01.c **** 			writeSPI(0);						/* Write 0 via SDI */
 255               	.LM18:
 256 0062 80E0      		ldi r24,0
 257 0064 00D0      		rcall writeSPI
 137:../libs-master-receiver/rfm01.c **** 		command <<= 1;							/* Shift left for next bit to send */
 259               	.LM19:
 260 0066 000F      		lsl r16
 261 0068 111F      		rol r17
 262 006a FA94      		dec r15
 129:../libs-master-receiver/rfm01.c **** 	while(n--)									/* Send All Bits MSB First */
 264               	.LM20:
 265 006c 01F0      		breq .L8
 266               	.L11:
 131:../libs-master-receiver/rfm01.c **** 		result <<= 1;                           /* Shift left for next bit to receive */
 268               	.LM21:
 269 006e CE01      		movw r24,r28
 270 0070 880F      		lsl r24
 271 0072 991F      		rol r25
 132:../libs-master-receiver/rfm01.c **** 		result |= ((inb(SPI_PIN) >> SDO) & 1);  /* add received bit to result */
 273               	.LM22:
 274 0074 29B1      		in r18,0x9
 275 0076 26FB      		bst r18,6
 276 0078 2227      		clr r18
 277 007a 20F9      		bld r18,0
 278 007c C22F      		mov r28,r18
 279 007e 20E0      		ldi r18,0
 280 0080 D22F      		mov r29,r18
 281 0082 C82B      		or r28,r24
 282 0084 D92B      		or r29,r25
 133:../libs-master-receiver/rfm01.c **** 		if (command & 0x8000)
 284               	.LM23:
 285 0086 17FF      		sbrs r17,7
 286 0088 00C0      		rjmp .L9
 134:../libs-master-receiver/rfm01.c **** 			writeSPI(1);						/* Write 1 via SDI */
 288               	.LM24:
 289 008a 81E0      		ldi r24,lo8(1)
 290 008c 00D0      		rcall writeSPI
 137:../libs-master-receiver/rfm01.c **** 		command <<= 1;							/* Shift left for next bit to send */
 292               	.LM25:
 293 008e 000F      		lsl r16
 294 0090 111F      		rol r17
 295 0092 FA94      		dec r15
 129:../libs-master-receiver/rfm01.c **** 	while(n--)									/* Send All Bits MSB First */
 297               	.LM26:
 298 0094 01F4      		brne .L11
 299               	.L8:
 139:../libs-master-receiver/rfm01.c **** 	sbi(CS_PORT,nSEL);							/* CS HIGH - Finished Sending Command */
 301               	.LM27:
 302 0096 5C9A      		sbi 0xb,4
 141:../libs-master-receiver/rfm01.c **** }
 304               	.LM28:
 305 0098 CE01      		movw r24,r28
 306               	/* epilogue start */
 307 009a DF91      		pop r29
 308 009c CF91      		pop r28
 309 009e 1F91      		pop r17
 310 00a0 0F91      		pop r16
 311 00a2 FF90      		pop r15
 312 00a4 0895      		ret
 313               	.L7:
 128:../libs-master-receiver/rfm01.c **** 	cbi(CS_PORT,nSEL);	                        /* Set CS LOW */
 315               	.LM29:
 316 00a6 5C98      		cbi 0xb,4
 317 00a8 00C0      		rjmp .L12
 318               	.L13:
 127:../libs-master-receiver/rfm01.c **** 	uint16_t result = 0;						/* Holds the received SDI */
 320               	.LM30:
 321 00aa C0E0      		ldi r28,0
 322 00ac D0E0      		ldi r29,0
 323 00ae 00C0      		rjmp .L8
 325               	.Lscope2:
 327               		.stabd	78,0,0
 329               	.global	resetFIFO
 331               	resetFIFO:
 332               		.stabd	46,0,0
  99:../libs-master-receiver/rfm01.c **** {
 334               	.LM31:
 335               	.LFBB3:
 336               	/* prologue: function */
 337               	/* frame size = 0 */
 338               	/* stack size = 0 */
 339               	.L__stack_usage = 0
 100:../libs-master-receiver/rfm01.c ****     writeCMD(FIFO, 16);
 341               	.LM32:
 342 00b0 60E1      		ldi r22,lo8(16)
 343 00b2 85E8      		ldi r24,lo8(-123)
 344 00b4 9EEC      		ldi r25,lo8(-50)
 345 00b6 00D0      		rcall writeCMD
 101:../libs-master-receiver/rfm01.c **** 	writeCMD(FIFO | _BV(1), 16);
 347               	.LM33:
 348 00b8 60E1      		ldi r22,lo8(16)
 349 00ba 87E8      		ldi r24,lo8(-121)
 350 00bc 9EEC      		ldi r25,lo8(-50)
 351 00be 00C0      		rjmp writeCMD
 353               	.Lscope3:
 355               		.stabd	78,0,0
 357               	.global	receiverConfigure
 359               	receiverConfigure:
 360               		.stabd	46,0,0
  72:../libs-master-receiver/rfm01.c **** {
 362               	.LM34:
 363               	.LFBB4:
 364               	/* prologue: function */
 365               	/* frame size = 0 */
 366               	/* stack size = 0 */
 367               	.L__stack_usage = 0
 368               	.LBB27:
 369               	.LBB28:
 371               	.Ltext10:
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 373               	.LM35:
 374 00c0 2FE7      		ldi r18,lo8(239999)
 375 00c2 89EA      		ldi r24,hi8(239999)
 376 00c4 93E0      		ldi r25,hlo8(239999)
 377 00c6 2150      		1: subi r18,1
 378 00c8 8040      		sbci r24,0
 379 00ca 9040      		sbci r25,0
 380 00cc 01F4      		brne 1b
 381 00ce 00C0      		rjmp .
 382 00d0 0000      		nop
 383               	.LBE28:
 384               	.LBE27:
 386               	.Ltext11:
  74:../libs-master-receiver/rfm01.c **** 	writeCMD(CONFIGURATION, 16);    /* Configure command */
 388               	.LM36:
 389 00d2 60E1      		ldi r22,lo8(16)
 390 00d4 8DE6      		ldi r24,lo8(109)
 391 00d6 99E8      		ldi r25,lo8(-119)
 392 00d8 00D0      		rcall writeCMD
  76:../libs-master-receiver/rfm01.c **** 	writeCMD(BATTERY, 16);
 394               	.LM37:
 395 00da 60E1      		ldi r22,lo8(16)
 396 00dc 80EE      		ldi r24,lo8(-32)
 397 00de 92EC      		ldi r25,lo8(-62)
 398 00e0 00D0      		rcall writeCMD
  77:../libs-master-receiver/rfm01.c **** 	writeCMD(FREQUENCY, 16);        /* Set carrier frequency */
 400               	.LM38:
 401 00e2 60E1      		ldi r22,lo8(16)
 402 00e4 80EB      		ldi r24,lo8(-80)
 403 00e6 94EA      		ldi r25,lo8(-92)
 404 00e8 00D0      		rcall writeCMD
  79:../libs-master-receiver/rfm01.c **** 	writeCMD(RECEIVER, 16);
 406               	.LM39:
 407 00ea 60E1      		ldi r22,lo8(16)
 408 00ec 80E4      		ldi r24,lo8(64)
 409 00ee 90EC      		ldi r25,lo8(-64)
 410 00f0 00D0      		rcall writeCMD
  81:../libs-master-receiver/rfm01.c **** 	writeCMD(RECEIVER | _BV(0), 16);
 412               	.LM40:
 413 00f2 60E1      		ldi r22,lo8(16)
 414 00f4 81E4      		ldi r24,lo8(65)
 415 00f6 90EC      		ldi r25,lo8(-64)
 416 00f8 00D0      		rcall writeCMD
  83:../libs-master-receiver/rfm01.c **** 	resetFIFO();
 418               	.LM41:
 419 00fa 00D0      		rcall resetFIFO
  85:../libs-master-receiver/rfm01.c **** 	writeCMD(BASEFILTER, 16);
 421               	.LM42:
 422 00fc 60E1      		ldi r22,lo8(16)
 423 00fe 8CEA      		ldi r24,lo8(-84)
 424 0100 94EC      		ldi r25,lo8(-60)
 425 0102 00D0      		rcall writeCMD
  87:../libs-master-receiver/rfm01.c **** 	writeCMD(DATARATE, 16);
 427               	.LM43:
 428 0104 60E1      		ldi r22,lo8(16)
 429 0106 83E2      		ldi r24,lo8(35)
 430 0108 98EC      		ldi r25,lo8(-56)
 431 010a 00D0      		rcall writeCMD
  89:../libs-master-receiver/rfm01.c **** 	writeCMD(AFC, 16);
 433               	.LM44:
 434 010c 60E1      		ldi r22,lo8(16)
 435 010e 8FEB      		ldi r24,lo8(-65)
 436 0110 96EC      		ldi r25,lo8(-58)
 437 0112 00C0      		rjmp writeCMD
 439               	.Lscope4:
 441               		.stabd	78,0,0
 443               	.global	readDataByte
 445               	readDataByte:
 446               		.stabd	46,0,0
 169:../libs-master-receiver/rfm01.c **** {
 448               	.LM45:
 449               	.LFBB5:
 450 0114 FF92      		push r15
 451 0116 0F93      		push r16
 452 0118 1F93      		push r17
 453 011a CF93      		push r28
 454 011c DF93      		push r29
 455               	/* prologue: function */
 456               	/* frame size = 0 */
 457               	/* stack size = 5 */
 458               	.L__stack_usage = 5
 173:../libs-master-receiver/rfm01.c **** 	cbi(CS_PORT,nSEL);	                        /* Set CS LOW */
 460               	.LM46:
 461 011e 5C98      		cbi 0xb,4
 462 0120 10E1      		ldi r17,lo8(16)
 171:../libs-master-receiver/rfm01.c **** 	uint16_t rfm01Status = 0;	     			/* Holds the RF01 status word */
 464               	.LM47:
 465 0122 C0E0      		ldi r28,0
 466 0124 D0E0      		ldi r29,0
 467               	.L22:
 176:../libs-master-receiver/rfm01.c **** 		rfm01Status <<= 1;                       /* Shift left for next bit received */
 469               	.LM48:
 470 0126 CE01      		movw r24,r28
 471 0128 880F      		lsl r24
 472 012a 991F      		rol r25
 177:../libs-master-receiver/rfm01.c **** 		rfm01Status |= ((inb(SPI_PIN) >> SDO) & 1);  /* add received bit to status */
 474               	.LM49:
 475 012c 29B1      		in r18,0x9
 476 012e 26FB      		bst r18,6
 477 0130 2227      		clr r18
 478 0132 20F9      		bld r18,0
 479 0134 C22F      		mov r28,r18
 480 0136 20E0      		ldi r18,0
 481 0138 D22F      		mov r29,r18
 482 013a C82B      		or r28,r24
 483 013c D92B      		or r29,r25
 178:../libs-master-receiver/rfm01.c **** 		writeSPI(0);						    /* Write 0 via SPI for status command */
 485               	.LM50:
 486 013e 80E0      		ldi r24,0
 487 0140 00D0      		rcall writeSPI
 488 0142 1150      		subi r17,lo8(-(-1))
 174:../libs-master-receiver/rfm01.c **** 	while(n--)                                  /* Start reading in the status word */
 490               	.LM51:
 491 0144 01F4      		brne .L22
 180:../libs-master-receiver/rfm01.c ****     lastRfm01Status = rfm01Status;
 493               	.LM52:
 494 0146 D093 0000 		sts lastRfm01Status+1,r29
 495 014a C093 0000 		sts lastRfm01Status,r28
 181:../libs-master-receiver/rfm01.c ****     if ((rfm01Status & 0x8000) != 0)             /* Check if FFIT is activated */
 497               	.LM53:
 498 014e D7FD      		sbrc r29,7
 499 0150 00C0      		rjmp .L26
 194:../libs-master-receiver/rfm01.c ****     sbi(CS_PORT,nSEL);					        /* CS high - finished sending status Command */
 501               	.LM54:
 502 0152 5C9A      		sbi 0xb,4
 196:../libs-master-receiver/rfm01.c **** }
 504               	.LM55:
 505 0154 CE01      		movw r24,r28
 506               	/* epilogue start */
 507 0156 DF91      		pop r29
 508 0158 CF91      		pop r28
 509 015a 1F91      		pop r17
 510 015c 0F91      		pop r16
 511 015e FF90      		pop r15
 512 0160 0895      		ret
 513               	.L26:
 181:../libs-master-receiver/rfm01.c ****     if ((rfm01Status & 0x8000) != 0)             /* Check if FFIT is activated */
 515               	.LM56:
 516 0162 48E0      		ldi r20,lo8(8)
 517 0164 F42E      		mov r15,r20
 518 0166 00E0      		ldi r16,0
 519 0168 10E0      		ldi r17,0
 520               	.L25:
 187:../libs-master-receiver/rfm01.c **** 		    result <<= 1;                       /* Shift left for next bit received */
 522               	.LM57:
 523 016a C801      		movw r24,r16
 524 016c 880F      		lsl r24
 525 016e 991F      		rol r25
 188:../libs-master-receiver/rfm01.c **** 		    result |= ((inb(SPI_PIN) >> SDO) & 1);  /* add received bit to result */
 527               	.LM58:
 528 0170 29B1      		in r18,0x9
 529 0172 26FB      		bst r18,6
 530 0174 0027      		clr r16
 531 0176 00F9      		bld r16,0
 532 0178 10E0      		ldi r17,0
 533 017a 082B      		or r16,r24
 534 017c 192B      		or r17,r25
 189:../libs-master-receiver/rfm01.c **** 		    writeSPI(0);						/* Write 0 via SPI for status command */
 536               	.LM59:
 537 017e 80E0      		ldi r24,0
 538 0180 00D0      		rcall writeSPI
 539 0182 FA94      		dec r15
 185:../libs-master-receiver/rfm01.c **** 	    while(n--)						        /* Continue to send zeros to get data */
 541               	.LM60:
 542 0184 01F4      		brne .L25
 191:../libs-master-receiver/rfm01.c ****         result |= (rfm01Status & 0xFF00);        /* return upper byte of status word with result */
 544               	.LM61:
 545 0186 CC27      		clr r28
 546 0188 C02B      		or r28,r16
 547 018a D12B      		or r29,r17
 194:../libs-master-receiver/rfm01.c ****     sbi(CS_PORT,nSEL);					        /* CS high - finished sending status Command */
 549               	.LM62:
 550 018c 5C9A      		sbi 0xb,4
 196:../libs-master-receiver/rfm01.c **** }
 552               	.LM63:
 553 018e CE01      		movw r24,r28
 554               	/* epilogue start */
 555 0190 DF91      		pop r29
 556 0192 CF91      		pop r28
 557 0194 1F91      		pop r17
 558 0196 0F91      		pop r16
 559 0198 FF90      		pop r15
 560 019a 0895      		ret
 565               	.Lscope5:
 567               		.stabd	78,0,0
 569               	.global	initSPI
 571               	initSPI:
 572               		.stabd	46,0,0
 219:../libs-master-receiver/rfm01.c ****     _delay_us(SPI_DELAY);                       /* delay to reduce rate to 250kbps */
 220:../libs-master-receiver/rfm01.c **** }
 221:../libs-master-receiver/rfm01.c **** 
 222:../libs-master-receiver/rfm01.c **** /****************************************************************************/
 223:../libs-master-receiver/rfm01.c **** /** @brief Initialize the SPI interface on the microcontroller port D upper four pins.
 224:../libs-master-receiver/rfm01.c **** This is not the microcontroller hardware SPI interface.
 225:../libs-master-receiver/rfm01.c **** */
 226:../libs-master-receiver/rfm01.c **** 
 227:../libs-master-receiver/rfm01.c **** void initSPI()
 228:../libs-master-receiver/rfm01.c **** {
 574               	.LM64:
 575               	.LFBB6:
 576               	/* prologue: function */
 577               	/* frame size = 0 */
 578               	/* stack size = 0 */
 579               	.L__stack_usage = 0
 229:../libs-master-receiver/rfm01.c **** /* Set pins for SDI, SCK and CS as outputs with nIRQ and SDO as input */
 230:../libs-master-receiver/rfm01.c ****     outb(SPI_SETUP,(inb(SPI_SETUP) | _BV(SDI) | _BV(SCK)) & ~_BV(nIRQ) & ~_BV(SDO));
 581               	.LM65:
 582 019c 8AB1      		in r24,0xa
 583 019e 8771      		andi r24,lo8(23)
 584 01a0 806A      		ori r24,lo8(-96)
 585 01a2 8AB9      		out 0xa,r24
 231:../libs-master-receiver/rfm01.c ****     outb(SPI_PORT,inb(SPI_PORT) & ~_BV(SDI) & ~_BV(SCK));/* Set outputs to zero */
 587               	.LM66:
 588 01a4 8BB1      		in r24,0xb
 589 01a6 8F75      		andi r24,lo8(95)
 590 01a8 8BB9      		out 0xb,r24
 232:../libs-master-receiver/rfm01.c ****     outb(CS_SETUP,inb(CS_SETUP) | _BV(nSEL));
 592               	.LM67:
 593 01aa 549A      		sbi 0xa,4
 233:../libs-master-receiver/rfm01.c ****     outb(CS_PORT,inb(CS_PORT) | _BV(nSEL));          /* Set high to deselect*/
 595               	.LM68:
 596 01ac 5C9A      		sbi 0xb,4
 597 01ae 0895      		ret
 599               	.Lscope6:
 601               		.stabd	78,0,0
 603               	.global	hardwareInit
 605               	hardwareInit:
 606               		.stabd	46,0,0
 608               	.Ltext12:
   1:power-control-master.c **** /**
   2:power-control-master.c **** @mainpage Power Control Project Master Unit
   3:power-control-master.c **** @version 0.0.0
   4:power-control-master.c **** @author Ken Sarkies (www.jiggerjuice.net)
   5:power-control-master.c **** @date 20 May 2011
   6:power-control-master.c **** @brief Code for a Master Power Switch unit
   7:power-control-master.c **** 
   8:power-control-master.c **** *** This sets the sleep mode, and requires the 8-bit timer 0 to generate
   9:power-control-master.c **** *** a timing tick.
  10:power-control-master.c **** 
  11:power-control-master.c **** This is a project to control power remotely using a wireless connection
  12:power-control-master.c **** between remote control units and a master switch unit. The master switch
  13:power-control-master.c **** board will interface to an ET-REL8 relay board using a 10 pin connector.
  14:power-control-master.c **** Each relay is activated by a separate port pin. It also interfaces to a
  15:power-control-master.c **** Hope RFM01 433MHz receiver module.
  16:power-control-master.c **** 
  17:power-control-master.c **** In principle the Master Power Switch units can be used for a wide range of
  18:power-control-master.c **** purposes as they simply receive command bytes over a serial link interface.
  19:power-control-master.c **** The interface used is the SPI interface to match the radio receiver module
  20:power-control-master.c **** RFM01. Other interfaces could simply be substituted.
  21:power-control-master.c **** 
  22:power-control-master.c **** The protocol used needs to match the sync pattern of the RF receiver:
  23:power-control-master.c **** 
  24:power-control-master.c **** AA AA AA 2D D4 ...
  25:power-control-master.c **** 
  26:power-control-master.c **** @note
  27:power-control-master.c **** Software: AVR-GCC 3.4.5
  28:power-control-master.c **** @note
  29:power-control-master.c **** Target:   Any AVR with sufficient output ports and a timer
  30:power-control-master.c **** @note
  31:power-control-master.c **** Tested:   ATMega48 at 8MHz internal clock.
  32:power-control-master.c ****  */
  33:power-control-master.c **** /***************************************************************************
  34:power-control-master.c ****  *   Copyright (C) 2011 by Ken Sarkies                                     *
  35:power-control-master.c ****  *   ksarkies@internode.on.net                                             *
  36:power-control-master.c ****  *                                                                         *
  37:power-control-master.c ****  *   This file is part of Power Controller                                 *
  38:power-control-master.c ****  *                                                                         *
  39:power-control-master.c ****  *   This is free software; you can redistribute it and/or modify          *
  40:power-control-master.c ****  *   it under the terms of the GNU General Public License as published by  *
  41:power-control-master.c ****  *   the Free Software Foundation; either version 2 of the License, or     *
  42:power-control-master.c ****  *   (at your option) any later version.                                   *
  43:power-control-master.c ****  *                                                                         *
  44:power-control-master.c ****  *   This software is distributed in the hope that it will be useful,      *
  45:power-control-master.c ****  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  46:power-control-master.c ****  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  47:power-control-master.c ****  *   GNU General Public License for more details.                          *
  48:power-control-master.c ****  *                                                                         *
  49:power-control-master.c ****  *   You should have received a copy of the GNU General Public License     *
  50:power-control-master.c ****  *   along with the software. If not, write to the:                        *
  51:power-control-master.c ****  *   Free Software Foundation, Inc.,                                       *
  52:power-control-master.c ****  *   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA.             *
  53:power-control-master.c ****  ***************************************************************************/
  54:power-control-master.c **** 
  55:power-control-master.c **** #define F_CPU               8000000
  56:power-control-master.c **** 
  57:power-control-master.c **** #include <inttypes.h>
  58:power-control-master.c **** #include <avr/sfr_defs.h>
  59:power-control-master.c **** #include <avr/wdt.h>
  60:power-control-master.c **** #include <avr/io.h>
  61:power-control-master.c **** #include <avr/interrupt.h>
  62:power-control-master.c **** #include <avr/sleep.h>
  63:power-control-master.c **** #include <util/delay.h>
  64:power-control-master.c **** #include "power-control-master.h"
  65:power-control-master.c **** #include "../libs-master-receiver/defines-M48.h"
  66:power-control-master.c **** #include "../libs-master-receiver/power-control-atmega48.h"
  67:power-control-master.c **** #include "../libs-master-receiver/timer.h"
  68:power-control-master.c **** #include "../libs-master-receiver/rfm01.h"
  69:power-control-master.c **** #include "../libs-master-receiver/rfm01.c"
  70:power-control-master.c **** 
  71:power-control-master.c **** /** Convenience macros (we don't use them all) */
  72:power-control-master.c **** #define TRUE 1
  73:power-control-master.c **** #define FALSE 0
  74:power-control-master.c **** 
  75:power-control-master.c **** #define inb(sfr) _SFR_BYTE(sfr)
  76:power-control-master.c **** #define inw(sfr) _SFR_WORD(sfr)
  77:power-control-master.c **** #define outb(sfr, val) (_SFR_BYTE(sfr) = (val))
  78:power-control-master.c **** #define outw(sfr, val) (_SFR_WORD(sfr) = (val))
  79:power-control-master.c **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  80:power-control-master.c **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  81:power-control-master.c **** #define high(x) ((uint8_t) (x >> 8) & 0xFF)
  82:power-control-master.c **** #define low(x) ((uint8_t) (x & 0xFF))
  83:power-control-master.c **** 
  84:power-control-master.c **** /*****************************************************************************/
  85:power-control-master.c **** /* Global Variables */
  86:power-control-master.c **** 
  87:power-control-master.c **** /** Set of 12 byte bins to count data received values. These will be used to
  88:power-control-master.c **** determine the median data value after a number of valid receives. */
  89:power-control-master.c **** uint8_t dataCount[12];
  90:power-control-master.c **** /** Real Time Clock Global Variable, ticks are 30.5 per second */
  91:power-control-master.c **** uint32_t timeValue;
  92:power-control-master.c **** 
  93:power-control-master.c **** /*****************************************************************************/
  94:power-control-master.c **** /* Local Prototypes */
  95:power-control-master.c **** 
  96:power-control-master.c **** void hardwareInit(void);
  97:power-control-master.c **** void wdtInit(void);
  98:power-control-master.c **** void snooze(void);
  99:power-control-master.c **** void setSwitch(uint8_t bestData);
 100:power-control-master.c **** void clearSwitches(void);
 101:power-control-master.c **** /*****************************************************************************/
 102:power-control-master.c **** /** @brief Main Program */
 103:power-control-master.c **** 
 104:power-control-master.c **** int main(void)
 105:power-control-master.c **** {
 106:power-control-master.c ****     hardwareInit();                 /* Initialize the processor specific hardware */
 107:power-control-master.c ****     timer0Init(0,5);                /* Configure the timer */
 108:power-control-master.c ****     timeValue = 0;                  /* reset timer */
 109:power-control-master.c ****     initSPI();
 110:power-control-master.c ****     receiverConfigure();            /* Initialize the receiver */
 111:power-control-master.c ****     uint8_t data = 0;
 112:power-control-master.c ****     uint8_t invalidData = 0;
 113:power-control-master.c ****     uint8_t validData = 0;
 114:power-control-master.c ****     uint8_t locked = FALSE;
 115:power-control-master.c ****     for (uint8_t bin=0; bin < 12; bin++) dataCount[bin] = 0;
 116:power-control-master.c **** 
 117:power-control-master.c **** /** The main loop will check for symbols received. This is tested for
 118:power-control-master.c **** validity and counted in bins to determine the median value as a best
 119:power-control-master.c **** estimate. Then the data is interpreted to toggle one of a number of ports
 120:power-control-master.c **** or perform other actions. The system is then locked to prevent any further
 121:power-control-master.c **** interpretations until a period of 2 seconds has elapsed following the last
 122:power-control-master.c **** valid received symbol. */
 123:power-control-master.c **** 
 124:power-control-master.c ****     for(;;)
 125:power-control-master.c ****     {
 126:power-control-master.c **** /** The processor sleeps until woken by a received byte or a timer tick */
 127:power-control-master.c ****         snooze();
 128:power-control-master.c **** 	    uint16_t receiverStatus = readDataByte();
 129:power-control-master.c **** /** The MSB of the status word is tested as FFIT. */
 130:power-control-master.c ****         if ((receiverStatus & 0x8000) != 0)    /* Check if something received */
 131:power-control-master.c ****         {
 132:power-control-master.c **** /** If nothing has been received for 2 seconds, release and clear the system to
 133:power-control-master.c **** allow other control commands to be activated. */
 134:power-control-master.c ****             if (timeValue > 61)
 135:power-control-master.c ****             {
 136:power-control-master.c ****                 locked = FALSE;
 137:power-control-master.c ****                 invalidData = 0;
 138:power-control-master.c ****                 validData = 0;
 139:power-control-master.c ****                 for (uint8_t bin=0; bin < 12; bin++) dataCount[bin] = 0;
 140:power-control-master.c ****             }
 141:power-control-master.c ****             timer0Init(0,5);
 142:power-control-master.c ****             timeValue = 0;                  /* reset timer */
 143:power-control-master.c ****             data = low(receiverStatus);
 144:power-control-master.c ****             resetFIFO();
 145:power-control-master.c **** /** When data is received, check if it is valid and increment its bin */
 146:power-control-master.c ****             if ((data < 12) && !locked)
 147:power-control-master.c ****             {
 148:power-control-master.c ****                 dataCount[data]++;
 149:power-control-master.c ****                 validData++;
 150:power-control-master.c ****             }
 151:power-control-master.c ****             else invalidData++;
 152:power-control-master.c **** /** Wait for 10 valid received data and then check the bins */
 153:power-control-master.c ****             if (validData == 10)
 154:power-control-master.c ****             {
 155:power-control-master.c ****                 locked = TRUE;              /* prevent more recognitions */
 156:power-control-master.c ****                 validData = 0;              /* prevent returning here while locked */
 157:power-control-master.c **** /** Look through bins and find the location of the peak (will return first equal peak) */
 158:power-control-master.c ****                 uint8_t maxData = 0;
 159:power-control-master.c ****                 uint8_t bestData = 0;
 160:power-control-master.c ****                 for (uint8_t i=0; i<12; i++)
 161:power-control-master.c ****                 {
 162:power-control-master.c ****                     if (dataCount[i] > maxData)
 163:power-control-master.c ****                     {
 164:power-control-master.c ****                         maxData = dataCount[i];
 165:power-control-master.c ****                         bestData = i;
 166:power-control-master.c ****                     }
 167:power-control-master.c ****                 }
 168:power-control-master.c **** /** With the estimated data value, set the appropriate port. Toggle the
 169:power-control-master.c **** existing value of the port. */
 170:power-control-master.c ****                 if (bestData < 10) setSwitch(bestData);
 171:power-control-master.c **** /** Use the remaining four symbols for general controls */
 172:power-control-master.c **** /* Turn off all ports */
 173:power-control-master.c ****                 else if (bestData == 11) clearSwitches();
 174:power-control-master.c ****             }
 175:power-control-master.c ****         }
 176:power-control-master.c ****     }
 177:power-control-master.c **** }
 178:power-control-master.c **** 
 179:power-control-master.c **** /****************************************************************************/
 180:power-control-master.c **** /** @brief Initialize the hardware.
 181:power-control-master.c **** */
 182:power-control-master.c **** void hardwareInit(void)
 183:power-control-master.c **** {
 610               	.LM69:
 611               	.LFBB7:
 612               	/* prologue: function */
 613               	/* frame size = 0 */
 614               	/* stack size = 0 */
 615               	.L__stack_usage = 0
 184:power-control-master.c **** /** Power down Timers 0,1, TWI, SPI, ADC and USART */
 185:power-control-master.c ****     outb(PRR,0xBF);
 617               	.LM70:
 618 01b0 8FEB      		ldi r24,lo8(-65)
 619 01b2 8093 6400 		sts 100,r24
 186:power-control-master.c **** /** We use Interrupt 1 with level triggering for power save mode */
 187:power-control-master.c ****     sbi(EIMSK,INT1);                /* Enable Interrupt 1 */
 621               	.LM71:
 622 01b6 E99A      		sbi 0x1d,1
 188:power-control-master.c ****     cbi(EICRA,ISC11);               /* Set level trigger on interrupt 1 */
 624               	.LM72:
 625 01b8 E9E6      		ldi r30,lo8(105)
 626 01ba F0E0      		ldi r31,0
 627 01bc 8081      		ld r24,Z
 628 01be 877F      		andi r24,lo8(-9)
 629 01c0 8083      		st Z,r24
 189:power-control-master.c ****     cbi(EICRA,ISC10);
 631               	.LM73:
 632 01c2 8081      		ld r24,Z
 633 01c4 8B7F      		andi r24,lo8(-5)
 634 01c6 8083      		st Z,r24
 190:power-control-master.c **** /** Set control ports as outputs */
 191:power-control-master.c ****     outb(DDRC,inb(DDRC) | 0x3F);
 636               	.LM74:
 637 01c8 87B1      		in r24,0x7
 638 01ca 8F63      		ori r24,lo8(63)
 639 01cc 87B9      		out 0x7,r24
 192:power-control-master.c ****     outb(DDRB,inb(DDRB) | 0x07);
 641               	.LM75:
 642 01ce 84B1      		in r24,0x4
 643 01d0 8760      		ori r24,lo8(7)
 644 01d2 84B9      		out 0x4,r24
 193:power-control-master.c ****     outb(DDRD,inb(DDRD) | 0x04);
 646               	.LM76:
 647 01d4 529A      		sbi 0xa,2
 194:power-control-master.c ****     sei();                          /* Enable global interrupts */
 649               	.LM77:
 650               	/* #APP */
 651               	 ;  194 "power-control-master.c" 1
 652 01d6 7894      		sei
 653               	 ;  0 "" 2
 654               	/* #NOAPP */
 655 01d8 0895      		ret
 657               	.Lscope7:
 659               		.stabd	78,0,0
 661               	.global	wdtInit
 663               	wdtInit:
 664               		.stabd	46,0,0
 195:power-control-master.c **** }
 196:power-control-master.c **** 
 197:power-control-master.c **** /****************************************************************************/
 198:power-control-master.c **** /** @brief Initialize the watchdog timer to interrupt on maximum delay
 199:power-control-master.c **** 
 200:power-control-master.c **** */
 201:power-control-master.c **** void wdtInit(void)
 202:power-control-master.c **** {
 666               	.LM78:
 667               	.LFBB8:
 668               	/* prologue: function */
 669               	/* frame size = 0 */
 670               	/* stack size = 0 */
 671               	.L__stack_usage = 0
 203:power-control-master.c **** /* Initialize the Watchdog timer to interrupt. */
 204:power-control-master.c **** /* IMPORTANT: Disable the "WDT Always On" fuse so that WDT can be turned off. */
 205:power-control-master.c ****     wdt_disable();     /* watchdog timer turn off ready for setup. */
 673               	.LM79:
 674 01da 88E1      		ldi r24,lo8(24)
 675               	/* #APP */
 676               	 ;  205 "power-control-master.c" 1
 677 01dc 0FB6      		in __tmp_reg__, __SREG__
 678 01de F894      		cli
 679 01e0 8093 6000 		sts 96, r24
 680 01e4 1092 6000 		sts 96, __zero_reg__
 681 01e8 0FBE      		out __SREG__,__tmp_reg__
 682               		
 683               	 ;  0 "" 2
 206:power-control-master.c ****     outb(WDTCR,0);
 685               	.LM80:
 686               	/* #NOAPP */
 687 01ea 1092 6000 		sts 96,__zero_reg__
 207:power-control-master.c **** /* Set the WDT with WDE clear, interrupts enabled, interrupt mode set, and
 208:power-control-master.c **** maximum timeout 8 seconds to give continuous interrupt mode. */
 209:power-control-master.c ****     sei();
 689               	.LM81:
 690               	/* #APP */
 691               	 ;  209 "power-control-master.c" 1
 692 01ee 7894      		sei
 693               	 ;  0 "" 2
 210:power-control-master.c **** //    outb(WDTCR,_BV(WDIE)|_BV(WDP3)|_BV(WDP0));
 211:power-control-master.c ****     outb(WDTCR,_BV(WDIE));  /* For test only: 32 ms timeout */
 695               	.LM82:
 696               	/* #NOAPP */
 697 01f0 80E4      		ldi r24,lo8(64)
 698 01f2 8093 6000 		sts 96,r24
 699 01f6 0895      		ret
 701               	.Lscope8:
 703               		.stabd	78,0,0
 705               	.global	snooze
 707               	snooze:
 708               		.stabd	46,0,0
 212:power-control-master.c **** 
 213:power-control-master.c **** }
 214:power-control-master.c **** 
 215:power-control-master.c **** /****************************************************************************/
 216:power-control-master.c **** /** @brief Send processor to sleep and manage interrupts.
 217:power-control-master.c **** 
 218:power-control-master.c **** This function is called at the beginning of every processing loop. The INT1
 219:power-control-master.c **** is enabled before sleeping, and disabled after wakeup.
 220:power-control-master.c **** */
 221:power-control-master.c **** void snooze(void)
 222:power-control-master.c **** {
 710               	.LM83:
 711               	.LFBB9:
 712               	/* prologue: function */
 713               	/* frame size = 0 */
 714               	/* stack size = 0 */
 715               	.L__stack_usage = 0
 223:power-control-master.c ****     sei();                              /* Enable global interrupts */
 717               	.LM84:
 718               	/* #APP */
 719               	 ;  223 "power-control-master.c" 1
 720 01f8 7894      		sei
 721               	 ;  0 "" 2
 224:power-control-master.c ****     sbi(EIMSK,INT1);                    /* Enable Interrupt 1 */
 723               	.LM85:
 724               	/* #NOAPP */
 725 01fa E99A      		sbi 0x1d,1
 225:power-control-master.c ****     set_sleep_mode(SLEEP_MODE_PWR_SAVE);
 727               	.LM86:
 728 01fc 83B7      		in r24,0x33
 729 01fe 817F      		andi r24,lo8(-15)
 730 0200 8660      		ori r24,lo8(6)
 731 0202 83BF      		out 0x33,r24
 226:power-control-master.c ****     sleep_mode();                       /* Enter sleep mode */
 733               	.LM87:
 734 0204 83B7      		in r24,0x33
 735 0206 8160      		ori r24,lo8(1)
 736 0208 83BF      		out 0x33,r24
 737               	/* #APP */
 738               	 ;  226 "power-control-master.c" 1
 739 020a 8895      		sleep
 740               		
 741               	 ;  0 "" 2
 742               	/* #NOAPP */
 743 020c 83B7      		in r24,0x33
 744 020e 8E7F      		andi r24,lo8(-2)
 745 0210 83BF      		out 0x33,r24
 227:power-control-master.c ****     cbi(EIMSK,INT1);                    /* Disable Interrupt 1 */
 747               	.LM88:
 748 0212 E998      		cbi 0x1d,1
 749 0214 0895      		ret
 751               	.Lscope9:
 753               		.stabd	78,0,0
 756               	.global	setSwitch
 758               	setSwitch:
 759               		.stabd	46,0,0
 228:power-control-master.c **** }
 229:power-control-master.c **** 
 230:power-control-master.c **** /****************************************************************************/
 231:power-control-master.c **** /** @brief Manage the power switching.
 232:power-control-master.c **** 
 233:power-control-master.c **** Adapt the switches 0-9 to the actual microcontroller port outputs.
 234:power-control-master.c **** 
 235:power-control-master.c **** @param[in] uint8_t bestData. The number of the switch to toggle.
 236:power-control-master.c **** */
 237:power-control-master.c **** void setSwitch(uint8_t bestData)
 238:power-control-master.c **** {
 761               	.LM89:
 762               	.LFBB10:
 763               	/* prologue: function */
 764               	/* frame size = 0 */
 765               	/* stack size = 0 */
 766               	.L__stack_usage = 0
 239:power-control-master.c ****     uint16_t bestBit = (1 << bestData);
 768               	.LM90:
 769 0216 21E0      		ldi r18,lo8(1)
 770 0218 30E0      		ldi r19,0
 771 021a 082E      		mov r0,r24
 772 021c 00C0      		rjmp 2f
 773               		1:
 774 021e 220F      		lsl r18
 775 0220 331F      		rol r19
 776               		2:
 777 0222 0A94      		dec r0
 778 0224 02F4      		brpl 1b
 240:power-control-master.c **** /* The lower 4 bits of PORTC are the first four ports */
 241:power-control-master.c ****     if (bestData < 4) outb(PORTC,inb(PORTC) ^ bestBit);
 780               	.LM91:
 781 0226 8430      		cpi r24,lo8(4)
 782 0228 00F0      		brlo .L36
 242:power-control-master.c **** /* The lower 3 bits of PORTB are the next three ports */
 243:power-control-master.c ****     else if (bestData < 7) outb(PORTB,inb(PORTB) ^ (bestBit >> 4));
 784               	.LM92:
 785 022a 8730      		cpi r24,lo8(7)
 786 022c 00F0      		brlo .L37
 244:power-control-master.c **** /* Bit 2 of PORTD is the eighth port */
 245:power-control-master.c ****     else if (bestData == 7) outb(PORTD,inb(PORTD) ^ 4);
 788               	.LM93:
 789 022e 8730      		cpi r24,lo8(7)
 790 0230 01F0      		breq .L38
 246:power-control-master.c **** /* Bits 4,5 of PORTC are the ninth and tenth ports */
 247:power-control-master.c ****     else if (bestData < 10) outb(PORTC,inb(PORTC) ^ (bestBit >> 4));
 792               	.LM94:
 793 0232 8A30      		cpi r24,lo8(10)
 794 0234 00F4      		brsh .L31
 796               	.LM95:
 797 0236 88B1      		in r24,0x8
 798 0238 3295      		swap r19
 799 023a 2295      		swap r18
 800 023c 2F70      		andi r18,0x0f
 801 023e 2327      		eor r18,r19
 802 0240 3F70      		andi r19,0x0f
 803 0242 2327      		eor r18,r19
 804 0244 8227      		eor r24,r18
 805 0246 88B9      		out 0x8,r24
 806               	.L31:
 807 0248 0895      		ret
 808               	.L37:
 243:power-control-master.c ****     else if (bestData < 7) outb(PORTB,inb(PORTB) ^ (bestBit >> 4));
 810               	.LM96:
 811 024a 85B1      		in r24,0x5
 812 024c 3295      		swap r19
 813 024e 2295      		swap r18
 814 0250 2F70      		andi r18,0x0f
 815 0252 2327      		eor r18,r19
 816 0254 3F70      		andi r19,0x0f
 817 0256 2327      		eor r18,r19
 818 0258 8227      		eor r24,r18
 819 025a 85B9      		out 0x5,r24
 820 025c 0895      		ret
 821               	.L36:
 241:power-control-master.c ****     if (bestData < 4) outb(PORTC,inb(PORTC) ^ bestBit);
 823               	.LM97:
 824 025e 88B1      		in r24,0x8
 825 0260 8227      		eor r24,r18
 826 0262 88B9      		out 0x8,r24
 827 0264 0895      		ret
 828               	.L38:
 245:power-control-master.c ****     else if (bestData == 7) outb(PORTD,inb(PORTD) ^ 4);
 830               	.LM98:
 831 0266 8BB1      		in r24,0xb
 832 0268 94E0      		ldi r25,lo8(4)
 833 026a 8927      		eor r24,r25
 834 026c 8BB9      		out 0xb,r24
 835 026e 0895      		ret
 837               	.Lscope10:
 839               		.stabd	78,0,0
 840               		.section	.text.startup,"ax",@progbits
 842               	.global	main
 844               	main:
 845               		.stabd	46,0,0
 105:power-control-master.c **** {
 847               	.LM99:
 848               	.LFBB11:
 849               	/* prologue: function */
 850               	/* frame size = 0 */
 851               	/* stack size = 0 */
 852               	.L__stack_usage = 0
 106:power-control-master.c ****     hardwareInit();                 /* Initialize the processor specific hardware */
 854               	.LM100:
 855 0000 00D0      		rcall hardwareInit
 107:power-control-master.c ****     timer0Init(0,5);                /* Configure the timer */
 857               	.LM101:
 858 0002 65E0      		ldi r22,lo8(5)
 859 0004 70E0      		ldi r23,0
 860 0006 80E0      		ldi r24,0
 861 0008 00D0      		rcall timer0Init
 108:power-control-master.c ****     timeValue = 0;                  /* reset timer */
 863               	.LM102:
 864 000a 1092 0000 		sts timeValue,__zero_reg__
 865 000e 1092 0000 		sts timeValue+1,__zero_reg__
 866 0012 1092 0000 		sts timeValue+2,__zero_reg__
 867 0016 1092 0000 		sts timeValue+3,__zero_reg__
 109:power-control-master.c ****     initSPI();
 869               	.LM103:
 870 001a 00D0      		rcall initSPI
 110:power-control-master.c ****     receiverConfigure();            /* Initialize the receiver */
 872               	.LM104:
 873 001c 00D0      		rcall receiverConfigure
 874 001e 00E0      		ldi r16,lo8(dataCount)
 875 0020 10E0      		ldi r17,hi8(dataCount)
 876 0022 C0E0      		ldi r28,lo8(dataCount+12)
 877 0024 D0E0      		ldi r29,hi8(dataCount+12)
 878 0026 F801      		movw r30,r16
 879               	.L42:
 880               	.LBB29:
 115:power-control-master.c ****     for (uint8_t bin=0; bin < 12; bin++) dataCount[bin] = 0;
 882               	.LM105:
 883 0028 1192      		st Z+,__zero_reg__
 884 002a 80E0      		ldi r24,hi8(dataCount+12)
 885 002c E030      		cpi r30,lo8(dataCount+12)
 886 002e F807      		cpc r31,r24
 887 0030 01F4      		brne .L42
 888               	.L58:
 889               	.LBE29:
 890               	.LBB30:
 136:power-control-master.c ****                 locked = FALSE;
 892               	.LM106:
 893 0032 C12C      		mov r12,__zero_reg__
 138:power-control-master.c ****                 validData = 0;
 895               	.LM107:
 896 0034 D12C      		mov r13,__zero_reg__
 897               	.L44:
 127:power-control-master.c ****         snooze();
 899               	.LM108:
 900 0036 00D0      		rcall snooze
 128:power-control-master.c **** 	    uint16_t receiverStatus = readDataByte();
 902               	.LM109:
 903 0038 00D0      		rcall readDataByte
 904 003a 7C01      		movw r14,r24
 130:power-control-master.c ****         if ((receiverStatus & 0x8000) != 0)    /* Check if something received */
 906               	.LM110:
 907 003c 97FF      		sbrs r25,7
 908 003e 00C0      		rjmp .L44
 134:power-control-master.c ****             if (timeValue > 61)
 910               	.LM111:
 911 0040 4091 0000 		lds r20,timeValue
 912 0044 5091 0000 		lds r21,timeValue+1
 913 0048 6091 0000 		lds r22,timeValue+2
 914 004c 7091 0000 		lds r23,timeValue+3
 915 0050 4E33      		cpi r20,62
 916 0052 5105      		cpc r21,__zero_reg__
 917 0054 6105      		cpc r22,__zero_reg__
 918 0056 7105      		cpc r23,__zero_reg__
 919 0058 00F0      		brlo .L45
 920 005a E0E0      		ldi r30,lo8(dataCount)
 921 005c F0E0      		ldi r31,hi8(dataCount)
 922               	.L47:
 923               	.LBB31:
 139:power-control-master.c ****                 for (uint8_t bin=0; bin < 12; bin++) dataCount[bin] = 0;
 925               	.LM112:
 926 005e 1192      		st Z+,__zero_reg__
 927 0060 CE17      		cp r28,r30
 928 0062 DF07      		cpc r29,r31
 929 0064 01F4      		brne .L47
 930               	.LBE31:
 141:power-control-master.c ****             timer0Init(0,5);
 932               	.LM113:
 933 0066 65E0      		ldi r22,lo8(5)
 934 0068 70E0      		ldi r23,0
 935 006a 80E0      		ldi r24,0
 936 006c 00D0      		rcall timer0Init
 142:power-control-master.c ****             timeValue = 0;                  /* reset timer */
 938               	.LM114:
 939 006e 1092 0000 		sts timeValue,__zero_reg__
 940 0072 1092 0000 		sts timeValue+1,__zero_reg__
 941 0076 1092 0000 		sts timeValue+2,__zero_reg__
 942 007a 1092 0000 		sts timeValue+3,__zero_reg__
 144:power-control-master.c ****             resetFIFO();
 944               	.LM115:
 945 007e 00D0      		rcall resetFIFO
 146:power-control-master.c ****             if ((data < 12) && !locked)
 947               	.LM116:
 948 0080 8BE0      		ldi r24,lo8(11)
 949 0082 8E15      		cp r24,r14
 950 0084 00F0      		brlo .L58
 951 0086 DD24      		clr r13
 952 0088 D394      		inc r13
 953               	.L54:
 954 008a F701      		movw r30,r14
 955 008c FF27      		clr r31
 148:power-control-master.c ****                 dataCount[data]++;
 957               	.LM117:
 958 008e E050      		subi r30,lo8(-(dataCount))
 959 0090 F040      		sbci r31,hi8(-(dataCount))
 960 0092 8081      		ld r24,Z
 961 0094 8F5F      		subi r24,lo8(-(1))
 962 0096 8083      		st Z,r24
 149:power-control-master.c ****                 validData++;
 964               	.LM118:
 965 0098 C12C      		mov r12,__zero_reg__
 966               	.L48:
 153:power-control-master.c ****             if (validData == 10)
 968               	.LM119:
 969 009a 8AE0      		ldi r24,lo8(10)
 970 009c D812      		cpse r13,r24
 971 009e 00C0      		rjmp .L44
 972 00a0 E0E0      		ldi r30,lo8(dataCount)
 973 00a2 F0E0      		ldi r31,hi8(dataCount)
 974 00a4 80E0      		ldi r24,0
 975 00a6 20E0      		ldi r18,0
 976               	.L52:
 977 00a8 3E2F      		mov r19,r30
 978 00aa 301B      		sub r19,r16
 979               	.LBB32:
 980               	.LBB33:
 162:power-control-master.c ****                     if (dataCount[i] > maxData)
 982               	.LM120:
 983 00ac 9191      		ld r25,Z+
 984 00ae 2917      		cp r18,r25
 985 00b0 00F4      		brsh .L50
 986 00b2 832F      		mov r24,r19
 987 00b4 292F      		mov r18,r25
 988               	.L50:
 160:power-control-master.c ****                 for (uint8_t i=0; i<12; i++)
 990               	.LM121:
 991 00b6 90E0      		ldi r25,hi8(dataCount+12)
 992 00b8 E030      		cpi r30,lo8(dataCount+12)
 993 00ba F907      		cpc r31,r25
 994 00bc 01F4      		brne .L52
 995               	.LBE33:
 170:power-control-master.c ****                 if (bestData < 10) setSwitch(bestData);
 997               	.LM122:
 998 00be 8A30      		cpi r24,lo8(10)
 999 00c0 00F0      		brlo .L59
 173:power-control-master.c ****                 else if (bestData == 11) clearSwitches();
 1001               	.LM123:
 1002 00c2 8B30      		cpi r24,lo8(11)
 1003 00c4 01F0      		breq .L60
 155:power-control-master.c ****                 locked = TRUE;              /* prevent more recognitions */
 1005               	.LM124:
 1006 00c6 CC24      		clr r12
 1007 00c8 C394      		inc r12
 156:power-control-master.c ****                 validData = 0;              /* prevent returning here while locked */
 1009               	.LM125:
 1010 00ca D12C      		mov r13,__zero_reg__
 1011 00cc 00C0      		rjmp .L44
 1012               	.L45:
 1013               	.LBE32:
 141:power-control-master.c ****             timer0Init(0,5);
 1015               	.LM126:
 1016 00ce 65E0      		ldi r22,lo8(5)
 1017 00d0 70E0      		ldi r23,0
 1018 00d2 80E0      		ldi r24,0
 1019 00d4 00D0      		rcall timer0Init
 142:power-control-master.c ****             timeValue = 0;                  /* reset timer */
 1021               	.LM127:
 1022 00d6 1092 0000 		sts timeValue,__zero_reg__
 1023 00da 1092 0000 		sts timeValue+1,__zero_reg__
 1024 00de 1092 0000 		sts timeValue+2,__zero_reg__
 1025 00e2 1092 0000 		sts timeValue+3,__zero_reg__
 144:power-control-master.c ****             resetFIFO();
 1027               	.LM128:
 1028 00e6 00D0      		rcall resetFIFO
 146:power-control-master.c ****             if ((data < 12) && !locked)
 1030               	.LM129:
 1031 00e8 9BE0      		ldi r25,lo8(11)
 1032 00ea 9E15      		cp r25,r14
 1033 00ec 00F0      		brlo .L48
 146:power-control-master.c ****             if ((data < 12) && !locked)
 1035               	.LM130:
 1036 00ee C110      		cpse r12,__zero_reg__
 1037 00f0 00C0      		rjmp .L48
 1038 00f2 D394      		inc r13
 1039 00f4 00C0      		rjmp .L54
 1040               	.L59:
 1041               	.LBB36:
 170:power-control-master.c ****                 if (bestData < 10) setSwitch(bestData);
 1043               	.LM131:
 1044 00f6 00D0      		rcall setSwitch
 155:power-control-master.c ****                 locked = TRUE;              /* prevent more recognitions */
 1046               	.LM132:
 1047 00f8 CC24      		clr r12
 1048 00fa C394      		inc r12
 156:power-control-master.c ****                 validData = 0;              /* prevent returning here while locked */
 1050               	.LM133:
 1051 00fc D12C      		mov r13,__zero_reg__
 1052 00fe 00C0      		rjmp .L44
 1053               	.L60:
 1054               	.LBB34:
 1055               	.LBB35:
 248:power-control-master.c **** }
 249:power-control-master.c **** 
 250:power-control-master.c **** /****************************************************************************/
 251:power-control-master.c **** /** @brief Turn off all power switching.
 252:power-control-master.c **** */
 253:power-control-master.c **** void clearSwitches(void)
 254:power-control-master.c **** {
 255:power-control-master.c ****     outb(PORTC,(inb(PORTC) & ~0x3F));
 1057               	.LM134:
 1058 0100 88B1      		in r24,0x8
 1059 0102 807C      		andi r24,lo8(-64)
 1060 0104 88B9      		out 0x8,r24
 256:power-control-master.c ****     outb(PORTB,(inb(PORTB) & ~0x07));
 1062               	.LM135:
 1063 0106 85B1      		in r24,0x5
 1064 0108 887F      		andi r24,lo8(-8)
 1065 010a 85B9      		out 0x5,r24
 257:power-control-master.c ****     outb(PORTD,(inb(PORTD) & ~0x04));
 1067               	.LM136:
 1068 010c 5A98      		cbi 0xb,2
 1069               	.LBE35:
 1070               	.LBE34:
 155:power-control-master.c ****                 locked = TRUE;              /* prevent more recognitions */
 1072               	.LM137:
 1073 010e CC24      		clr r12
 1074 0110 C394      		inc r12
 156:power-control-master.c ****                 validData = 0;              /* prevent returning here while locked */
 1076               	.LM138:
 1077 0112 D12C      		mov r13,__zero_reg__
 1078 0114 00C0      		rjmp .L44
 1079               	.LBE36:
 1080               	.LBE30:
 1089               	.Lscope11:
 1091               		.stabd	78,0,0
 1092               		.text
 1094               	.global	clearSwitches
 1096               	clearSwitches:
 1097               		.stabd	46,0,0
 254:power-control-master.c **** {
 1099               	.LM139:
 1100               	.LFBB12:
 1101               	/* prologue: function */
 1102               	/* frame size = 0 */
 1103               	/* stack size = 0 */
 1104               	.L__stack_usage = 0
 255:power-control-master.c ****     outb(PORTC,(inb(PORTC) & ~0x3F));
 1106               	.LM140:
 1107 0270 88B1      		in r24,0x8
 1108 0272 807C      		andi r24,lo8(-64)
 1109 0274 88B9      		out 0x8,r24
 256:power-control-master.c ****     outb(PORTB,(inb(PORTB) & ~0x07));
 1111               	.LM141:
 1112 0276 85B1      		in r24,0x5
 1113 0278 887F      		andi r24,lo8(-8)
 1114 027a 85B9      		out 0x5,r24
 1116               	.LM142:
 1117 027c 5A98      		cbi 0xb,2
 1118 027e 0895      		ret
 1120               	.Lscope12:
 1122               		.stabd	78,0,0
 1124               	.global	__vector_2
 1126               	__vector_2:
 1127               		.stabd	46,0,0
 258:power-control-master.c **** }
 259:power-control-master.c **** /****************************************************************************/
 260:power-control-master.c **** /** @brief Interrupt on nIRQ from Receiver.
 261:power-control-master.c **** 
 262:power-control-master.c **** This ISR does nothing except to allow the processor to wakeup.
 263:power-control-master.c **** */
 264:power-control-master.c **** ISR(REC_INTERRUPT)
 265:power-control-master.c **** {
 1129               	.LM143:
 1130               	.LFBB13:
 1131 0280 1F92      		push r1
 1132 0282 0F92      		push r0
 1133 0284 0FB6      		in r0,__SREG__
 1134 0286 0F92      		push r0
 1135 0288 1124      		clr __zero_reg__
 1136               	/* prologue: Signal */
 1137               	/* frame size = 0 */
 1138               	/* stack size = 3 */
 1139               	.L__stack_usage = 3
 1140               	/* epilogue start */
 266:power-control-master.c **** }
 1142               	.LM144:
 1143 028a 0F90      		pop r0
 1144 028c 0FBE      		out __SREG__,r0
 1145 028e 0F90      		pop r0
 1146 0290 1F90      		pop r1
 1147 0292 1895      		reti
 1149               	.Lscope13:
 1151               		.stabd	78,0,0
 1153               	.global	__vector_16
 1155               	__vector_16:
 1156               		.stabd	46,0,0
 267:power-control-master.c **** 
 268:power-control-master.c **** /****************************************************************************/
 269:power-control-master.c **** /** @brief Interrupt on RTC timer overflow
 270:power-control-master.c **** 
 271:power-control-master.c **** This ISR simply updates the RTC.
 272:power-control-master.c **** */
 273:power-control-master.c **** ISR(TIMER_INTERRUPT)
 274:power-control-master.c **** {
 1158               	.LM145:
 1159               	.LFBB14:
 1160 0294 1F92      		push r1
 1161 0296 0F92      		push r0
 1162 0298 0FB6      		in r0,__SREG__
 1163 029a 0F92      		push r0
 1164 029c 1124      		clr __zero_reg__
 1165 029e 8F93      		push r24
 1166 02a0 9F93      		push r25
 1167 02a2 AF93      		push r26
 1168 02a4 BF93      		push r27
 1169               	/* prologue: Signal */
 1170               	/* frame size = 0 */
 1171               	/* stack size = 7 */
 1172               	.L__stack_usage = 7
 275:power-control-master.c ****   timeValue++;
 1174               	.LM146:
 1175 02a6 8091 0000 		lds r24,timeValue
 1176 02aa 9091 0000 		lds r25,timeValue+1
 1177 02ae A091 0000 		lds r26,timeValue+2
 1178 02b2 B091 0000 		lds r27,timeValue+3
 1179 02b6 0196      		adiw r24,1
 1180 02b8 A11D      		adc r26,__zero_reg__
 1181 02ba B11D      		adc r27,__zero_reg__
 1182 02bc 8093 0000 		sts timeValue,r24
 1183 02c0 9093 0000 		sts timeValue+1,r25
 1184 02c4 A093 0000 		sts timeValue+2,r26
 1185 02c8 B093 0000 		sts timeValue+3,r27
 1186               	/* epilogue start */
 276:power-control-master.c **** }
 1188               	.LM147:
 1189 02cc BF91      		pop r27
 1190 02ce AF91      		pop r26
 1191 02d0 9F91      		pop r25
 1192 02d2 8F91      		pop r24
 1193 02d4 0F90      		pop r0
 1194 02d6 0FBE      		out __SREG__,r0
 1195 02d8 0F90      		pop r0
 1196 02da 1F90      		pop r1
 1197 02dc 1895      		reti
 1199               	.Lscope14:
 1201               		.stabd	78,0,0
 1202               		.comm	timeValue,4,1
 1203               		.comm	dataCount,12,1
 1204               	.global	lastRfm01Status
 1205               		.section .bss
 1208               	lastRfm01Status:
 1209 0000 0000      		.zero	2
 1213               		.text
 1215               	.Letext0:
 1216               		.ident	"GCC: (GNU) 4.8.2"
 1217               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 power-control-master.c
     /tmp/ccCqXBmb.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccCqXBmb.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccCqXBmb.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccCqXBmb.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccCqXBmb.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccCqXBmb.s:106    .text:0000000000000000 writeSPI
     /tmp/ccCqXBmb.s:205    .text:0000000000000032 writeCMD
     /tmp/ccCqXBmb.s:331    .text:00000000000000b0 resetFIFO
     /tmp/ccCqXBmb.s:359    .text:00000000000000c0 receiverConfigure
     /tmp/ccCqXBmb.s:445    .text:0000000000000114 readDataByte
     /tmp/ccCqXBmb.s:1208   .bss:0000000000000000 lastRfm01Status
     /tmp/ccCqXBmb.s:571    .text:000000000000019c initSPI
     /tmp/ccCqXBmb.s:605    .text:00000000000001b0 hardwareInit
     /tmp/ccCqXBmb.s:663    .text:00000000000001da wdtInit
     /tmp/ccCqXBmb.s:707    .text:00000000000001f8 snooze
     /tmp/ccCqXBmb.s:758    .text:0000000000000216 setSwitch
     /tmp/ccCqXBmb.s:844    .text.startup:0000000000000000 main
                            *COM*:0000000000000004 timeValue
                            *COM*:000000000000000c dataCount
     /tmp/ccCqXBmb.s:1096   .text:0000000000000270 clearSwitches
     /tmp/ccCqXBmb.s:1126   .text:0000000000000280 __vector_2
     /tmp/ccCqXBmb.s:1155   .text:0000000000000294 __vector_16

UNDEFINED SYMBOLS
timer0Init
__do_clear_bss
