   1               		.file	"serial-link-transceiver.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 113               	spi_data:
 114               		.stabd	46,0,0
 116               	.Ltext1:
   1:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** /**** RFM 12 library for Atmel AVR Microcontrollers *******
   2:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  *
   3:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * This software is free software; you can redistribute it and/or modify
   4:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * it under the terms of the GNU General Public License as published
   5:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * by the Free Software Foundation; either version 2 of the License,
   6:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * or (at your option) any later version.
   7:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  *
   8:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * This software is distributed in the hope that it will be useful, but
   9:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * WITHOUT ANY WARRANTY; without even the implied warranty of
  10:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  11:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * General Public License for more details.
  12:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  *
  13:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * You should have received a copy of the GNU General Public License
  14:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * along with this software; if not, write to the Free Software
  15:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
  16:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * USA.
  17:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  *
  18:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * @author Peter Fuhrmann, Hans-Gert Dahmen, Soeren Heisrath
  19:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  */
  20:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
  21:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** /******************************************************
  22:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  *    THIS FILE IS BEING INCLUDED DIRECTLY		*
  23:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  *		(for performance reasons)				*
  24:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  ******************************************************/
  25:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  
  26:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** //hardware spi helper macros
  27:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** #define SS_ASSERT() PORT_SS &= ~(1<<BIT_SS)
  28:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** #define SS_RELEASE() PORT_SS |= (1<<BIT_SS)
  29:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
  30:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
  31:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** #if RFM12_SPI_SOFTWARE
  32:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** /* @description Actual sending function to send raw data to the Module
  33:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * @note do NOT call this function directly, unless you know what you're doing.
  34:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  */
  35:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** static uint8_t spi_data(uint8_t c)
  36:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** {
 118               	.LM0:
 119               	.LFBB1:
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 0 */
 123               	.L__stack_usage = 0
 125               	.LM1:
 126 0000 28E0      		ldi r18,lo8(8)
 127 0002 00C0      		rjmp .L6
 128               	.L2:
  37:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	uint8_t x, d=d;
  38:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	for(x=0;x<8;x++){
  39:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		if(c & 0x80){
  40:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 			PORT_MOSI |= (1<<BIT_MOSI);
  41:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		}else{
  42:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 			PORT_MOSI &= ~(1<<BIT_MOSI);	
 130               	.LM2:
 131 0004 5F98      		cbi 0xb,7
 132               	.L3:
  43:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		}
  44:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		PORT_SCK |= (1<<BIT_SCK);
 134               	.LM3:
 135 0006 5D9A      		sbi 0xb,5
  45:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		d<<=1;
 137               	.LM4:
 138 0008 990F      		lsl r25
  46:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		if(PIN_MISO & (1<<BIT_MISO)){
 140               	.LM5:
 141 000a 4E99      		sbic 0x9,6
  47:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 			d|=1;
 143               	.LM6:
 144 000c 9160      		ori r25,lo8(1)
 145               	.L4:
  48:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		}
  49:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		PORT_SCK &= ~(1<<BIT_SCK);
 147               	.LM7:
 148 000e 5D98      		cbi 0xb,5
  50:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		c<<=1;
 150               	.LM8:
 151 0010 880F      		lsl r24
 152 0012 2150      		subi r18,lo8(-(-1))
  38:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	for(x=0;x<8;x++){
 154               	.LM9:
 155 0014 01F0      		breq .L11
 156               	.L6:
  39:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		if(c & 0x80){
 158               	.LM10:
 159 0016 87FF      		sbrs r24,7
 160 0018 00C0      		rjmp .L2
  40:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 			PORT_MOSI |= (1<<BIT_MOSI);
 162               	.LM11:
 163 001a 5F9A      		sbi 0xb,7
 164 001c 00C0      		rjmp .L3
 165               	.L11:
  51:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	}
  52:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	return d;
  53:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** }
 167               	.LM12:
 168 001e 892F      		mov r24,r25
 169 0020 0895      		ret
 174               	.Lscope1:
 176               		.stabd	78,0,0
 178               	.global	rfm12_data
 180               	rfm12_data:
 181               		.stabd	46,0,0
  54:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** #endif
  55:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
  56:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
  57:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** //non-inlined version of rfm12_data
  58:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** //warning: without the attribute, gcc will inline this even if -Os is set
  59:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** void __attribute__ ((noinline)) rfm12_data(uint16_t d)
  60:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** {
 183               	.LM13:
 184               	.LFBB2:
 185 0022 CF93      		push r28
 186               	/* prologue: function */
 187               	/* frame size = 0 */
 188               	/* stack size = 1 */
 189               	.L__stack_usage = 1
 190 0024 C82F      		mov r28,r24
  61:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SS_ASSERT();
 192               	.LM14:
 193 0026 5C98      		cbi 0xb,4
  62:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#if !(RFM12_SPI_SOFTWARE)
  63:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SPDR = d>>8;
  64:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	while(!(SPSR & (1<<SPIF)));
  65:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
  66:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SPDR = d & 0xff;
  67:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	while(!(SPSR & (1<<SPIF)));
  68:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	
  69:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#else
  70:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	spi_data(d >> 8   );
 195               	.LM15:
 196 0028 892F      		mov r24,r25
 197 002a 00D0      		rcall spi_data
  71:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	spi_data(d &  0xff);
 199               	.LM16:
 200 002c 8C2F      		mov r24,r28
 201 002e 00D0      		rcall spi_data
  72:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#endif
  73:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SS_RELEASE();
 203               	.LM17:
 204 0030 5C9A      		sbi 0xb,4
 205               	/* epilogue start */
  74:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** }
 207               	.LM18:
 208 0032 CF91      		pop r28
 209 0034 0895      		ret
 211               	.Lscope2:
 213               		.stabd	78,0,0
 215               	.global	rfm12_read
 217               	rfm12_read:
 218               		.stabd	46,0,0
  75:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
  76:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
  77:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** //non-inlined version of rfm12_read
  78:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** //warning: without the attribute, gcc will inline this even if -Os is set
  79:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** uint16_t __attribute__ ((noinline)) rfm12_read(uint16_t c)
  80:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** {
 220               	.LM19:
 221               	.LFBB3:
 222 0036 1F93      		push r17
 223 0038 CF93      		push r28
 224 003a DF93      		push r29
 225               	/* prologue: function */
 226               	/* frame size = 0 */
 227               	/* stack size = 3 */
 228               	.L__stack_usage = 3
 229 003c 182F      		mov r17,r24
  81:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	uint16_t retval;
  82:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SS_ASSERT();
 231               	.LM20:
 232 003e 5C98      		cbi 0xb,4
  83:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	
  84:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#if !(RFM12_SPI_SOFTWARE)
  85:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SPDR = c>>8;
  86:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	while(!(SPSR & (1<<SPIF)));
  87:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	retval = SPDR<<8;
  88:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SPDR = c & 0xff;
  89:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	while(!(SPSR & (1<<SPIF)));
  90:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	retval |= SPDR;
  91:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	
  92:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#else
  93:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	retval =  spi_data(c >> 8   );
 234               	.LM21:
 235 0040 892F      		mov r24,r25
 236 0042 00D0      		rcall spi_data
 237 0044 C82F      		mov r28,r24
 238 0046 D0E0      		ldi r29,0
  94:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	retval <<= 8;
 240               	.LM22:
 241 0048 DC2F      		mov r29,r28
 242 004a CC27      		clr r28
  95:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	retval |= spi_data(c &  0xff);
 244               	.LM23:
 245 004c 812F      		mov r24,r17
 246 004e 00D0      		rcall spi_data
  96:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#endif
  97:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SS_RELEASE();
 248               	.LM24:
 249 0050 5C9A      		sbi 0xb,4
  98:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	return retval;
  99:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** }
 251               	.LM25:
 252 0052 9E01      		movw r18,r28
 253 0054 282B      		or r18,r24
 254 0056 C901      		movw r24,r18
 255               	/* epilogue start */
 256 0058 DF91      		pop r29
 257 005a CF91      		pop r28
 258 005c 1F91      		pop r17
 259 005e 0895      		ret
 261               	.Lscope3:
 263               		.stabd	78,0,0
 265               	.global	rfm12_read_int_flags_inline
 267               	rfm12_read_int_flags_inline:
 268               		.stabd	46,0,0
 100:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 101:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 102:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** /* @description reads the upper 8 bits of the status
 103:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  * register (the interrupt flags)
 104:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  */
 105:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  uint8_t rfm12_read_int_flags_inline()
 106:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** {
 270               	.LM26:
 271               	.LFBB4:
 272               	/* prologue: function */
 273               	/* frame size = 0 */
 274               	/* stack size = 0 */
 275               	.L__stack_usage = 0
 107:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SS_ASSERT();
 277               	.LM27:
 278 0060 5C98      		cbi 0xb,4
 108:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#if !(RFM12_SPI_SOFTWARE)
 109:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SPDR = 0;
 110:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	while(!(SPSR & (1<<SPIF)));
 111:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SS_RELEASE();
 112:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	return SPDR;
 113:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 114:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#else
 115:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	unsigned char x, d=d;
 116:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	PORT_MOSI &= ~(1<<BIT_MOSI);	
 280               	.LM28:
 281 0062 5F98      		cbi 0xb,7
 282 0064 98E0      		ldi r25,lo8(8)
 283               	.L17:
 117:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	for(x=0;x<8;x++){
 118:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		PORT_SCK |= (1<<BIT_SCK);
 285               	.LM29:
 286 0066 5D9A      		sbi 0xb,5
 119:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		d<<=1;
 288               	.LM30:
 289 0068 880F      		lsl r24
 120:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		if(PIN_MISO & (1<<BIT_MISO)){
 291               	.LM31:
 292 006a 4E99      		sbic 0x9,6
 121:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 			d|=1;
 294               	.LM32:
 295 006c 8160      		ori r24,lo8(1)
 296               	.L15:
 122:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		}
 123:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 		PORT_SCK &= ~(1<<BIT_SCK);
 298               	.LM33:
 299 006e 5D98      		cbi 0xb,5
 300 0070 9150      		subi r25,lo8(-(-1))
 117:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	for(x=0;x<8;x++){
 302               	.LM34:
 303 0072 01F4      		brne .L17
 124:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	}
 125:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SS_RELEASE();
 305               	.LM35:
 306 0074 5C9A      		sbi 0xb,4
 126:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	return d;
 127:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#endif
 128:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** }
 308               	.LM36:
 309 0076 0895      		ret
 314               	.Lscope4:
 316               		.stabd	78,0,0
 320               	.global	rfm12_data_inline
 322               	rfm12_data_inline:
 323               		.stabd	46,0,0
 129:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 130:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 131:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** /* @description inline version of rfm12_data for use in interrupt
 132:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  */
 133:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** void rfm12_data_inline(uint8_t cmd, uint8_t d)
 134:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** {
 325               	.LM37:
 326               	.LFBB5:
 327 0078 CF93      		push r28
 328 007a DF93      		push r29
 329 007c 1F92      		push __zero_reg__
 330 007e CDB7      		in r28,__SP_L__
 331 0080 DEB7      		in r29,__SP_H__
 332               	/* prologue: function */
 333               	/* frame size = 1 */
 334               	/* stack size = 3 */
 335               	.L__stack_usage = 3
 135:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SS_ASSERT();
 337               	.LM38:
 338 0082 5C98      		cbi 0xb,4
 136:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#if !(RFM12_SPI_SOFTWARE)
 137:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SPDR = cmd;
 138:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	while(!(SPSR & (1<<SPIF)));
 139:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 140:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SPDR = d;
 141:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	while(!(SPSR & (1<<SPIF)));
 142:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	
 143:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#else
 144:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	spi_data( cmd );
 340               	.LM39:
 341 0084 6983      		std Y+1,r22
 342 0086 00D0      		rcall spi_data
 145:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	spi_data( d   );
 344               	.LM40:
 345 0088 6981      		ldd r22,Y+1
 346 008a 862F      		mov r24,r22
 347 008c 00D0      		rcall spi_data
 146:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#endif
 147:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SS_RELEASE();
 349               	.LM41:
 350 008e 5C9A      		sbi 0xb,4
 351               	/* epilogue start */
 148:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** }
 353               	.LM42:
 354 0090 0F90      		pop __tmp_reg__
 355 0092 DF91      		pop r29
 356 0094 CF91      		pop r28
 357 0096 0895      		ret
 359               	.Lscope5:
 361               		.stabd	78,0,0
 363               	.global	rfm12_read_fifo_inline
 365               	rfm12_read_fifo_inline:
 366               		.stabd	46,0,0
 149:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 150:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 151:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** /* @description inline function for reading the fifo
 152:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c ****  */
 153:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** uint8_t rfm12_read_fifo_inline()
 154:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** {
 368               	.LM43:
 369               	.LFBB6:
 370               	/* prologue: function */
 371               	/* frame size = 0 */
 372               	/* stack size = 0 */
 373               	.L__stack_usage = 0
 155:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SS_ASSERT();
 375               	.LM44:
 376 0098 5C98      		cbi 0xb,4
 156:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 157:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#if !(RFM12_SPI_SOFTWARE)
 158:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SPDR =  ( RFM12_CMD_READ >> 8 );
 159:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	while(!(SPSR & (1<<SPIF)));
 160:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 161:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SPDR = 0;
 162:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	while(!(SPSR & (1<<SPIF)));
 163:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 164:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SS_RELEASE();
 165:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	return SPDR;
 166:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	
 167:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#else
 168:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	uint8_t retval;
 169:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	spi_data( RFM12_CMD_READ >> 8 );
 378               	.LM45:
 379 009a 80EB      		ldi r24,lo8(-80)
 380 009c 00D0      		rcall spi_data
 170:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	retval = spi_data( 0   );
 382               	.LM46:
 383 009e 80E0      		ldi r24,0
 384 00a0 00D0      		rcall spi_data
 171:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 172:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	SS_RELEASE();
 386               	.LM47:
 387 00a2 5C9A      		sbi 0xb,4
 173:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	return retval;
 174:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	#endif
 175:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** }
 389               	.LM48:
 390 00a4 0895      		ret
 392               	.Lscope6:
 394               		.stabd	78,0,0
 396               	.global	spi_init
 398               	spi_init:
 399               		.stabd	46,0,0
 176:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 
 177:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** void spi_init()
 178:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** {
 401               	.LM49:
 402               	.LFBB7:
 403               	/* prologue: function */
 404               	/* frame size = 0 */
 405               	/* stack size = 0 */
 406               	.L__stack_usage = 0
 179:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	DDR_MOSI   |= (_BV(BIT_MOSI));
 408               	.LM50:
 409 00a6 579A      		sbi 0xa,7
 180:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	DDR_SCK    |= (_BV(BIT_SCK));
 411               	.LM51:
 412 00a8 559A      		sbi 0xa,5
 181:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	DDR_SPI_SS |= (_BV(BIT_SPI_SS));
 414               	.LM52:
 415 00aa 549A      		sbi 0xa,4
 182:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	DDR_MISO   &= ~(_BV(BIT_MISO));
 417               	.LM53:
 418 00ac 5698      		cbi 0xa,6
 419 00ae 0895      		ret
 421               	.Lscope7:
 423               		.stabd	78,0,0
 425               	.global	__vector_2
 427               	__vector_2:
 428               		.stabd	46,0,0
 430               	.Ltext2:
   1:../auxiliary/rfm12-1.1/src/rfm12.c **** /**** RFM 12 library for Atmel AVR Microcontrollers *******
   2:../auxiliary/rfm12-1.1/src/rfm12.c ****  * 
   3:../auxiliary/rfm12-1.1/src/rfm12.c ****  * This software is free software; you can redistribute it and/or modify
   4:../auxiliary/rfm12-1.1/src/rfm12.c ****  * it under the terms of the GNU General Public License as published
   5:../auxiliary/rfm12-1.1/src/rfm12.c ****  * by the Free Software Foundation; either version 2 of the License,
   6:../auxiliary/rfm12-1.1/src/rfm12.c ****  * or (at your option) any later version.
   7:../auxiliary/rfm12-1.1/src/rfm12.c ****  *
   8:../auxiliary/rfm12-1.1/src/rfm12.c ****  * This software is distributed in the hope that it will be useful, but
   9:../auxiliary/rfm12-1.1/src/rfm12.c ****  * WITHOUT ANY WARRANTY; without even the implied warranty of
  10:../auxiliary/rfm12-1.1/src/rfm12.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  11:../auxiliary/rfm12-1.1/src/rfm12.c ****  * General Public License for more details.
  12:../auxiliary/rfm12-1.1/src/rfm12.c ****  *
  13:../auxiliary/rfm12-1.1/src/rfm12.c ****  * You should have received a copy of the GNU General Public License
  14:../auxiliary/rfm12-1.1/src/rfm12.c ****  * along with this software; if not, write to the Free Software
  15:../auxiliary/rfm12-1.1/src/rfm12.c ****  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
  16:../auxiliary/rfm12-1.1/src/rfm12.c ****  * USA.
  17:../auxiliary/rfm12-1.1/src/rfm12.c ****  *
  18:../auxiliary/rfm12-1.1/src/rfm12.c ****  * @author Peter Fuhrmann, Hans-Gert Dahmen, Soeren Heisrath
  19:../auxiliary/rfm12-1.1/src/rfm12.c ****  */
  20:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  21:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  22:../auxiliary/rfm12-1.1/src/rfm12.c **** /** \file rfm12.c
  23:../auxiliary/rfm12-1.1/src/rfm12.c ****  * \brief rfm12 library main file
  24:../auxiliary/rfm12-1.1/src/rfm12.c ****  * \author Hans-Gert Dahmen
  25:../auxiliary/rfm12-1.1/src/rfm12.c ****  * \author Peter Fuhrmann
  26:../auxiliary/rfm12-1.1/src/rfm12.c ****  * \author Soeren Heisrath
  27:../auxiliary/rfm12-1.1/src/rfm12.c ****  * \version 0.9.0
  28:../auxiliary/rfm12-1.1/src/rfm12.c ****  * \date 08.09.09
  29:../auxiliary/rfm12-1.1/src/rfm12.c ****  *
  30:../auxiliary/rfm12-1.1/src/rfm12.c ****  * All core functionality is implemented within this file.
  31:../auxiliary/rfm12-1.1/src/rfm12.c ****  */
  32:../auxiliary/rfm12-1.1/src/rfm12.c ****  
  33:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  34:../auxiliary/rfm12-1.1/src/rfm12.c **** /************************
  35:../auxiliary/rfm12-1.1/src/rfm12.c ****  * standard includes
  36:../auxiliary/rfm12-1.1/src/rfm12.c **** */
  37:../auxiliary/rfm12-1.1/src/rfm12.c **** #include <avr/io.h>
  38:../auxiliary/rfm12-1.1/src/rfm12.c **** #include <avr/interrupt.h>
  39:../auxiliary/rfm12-1.1/src/rfm12.c **** #include <string.h>
  40:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  41:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  42:../auxiliary/rfm12-1.1/src/rfm12.c **** /************************
  43:../auxiliary/rfm12-1.1/src/rfm12.c ****  * library internal includes
  44:../auxiliary/rfm12-1.1/src/rfm12.c ****  * the order in which they are included is important
  45:../auxiliary/rfm12-1.1/src/rfm12.c **** */
  46:../auxiliary/rfm12-1.1/src/rfm12.c **** #include "include/rfm12_hw.h"
  47:../auxiliary/rfm12-1.1/src/rfm12.c **** #include "include/rfm12_core.h"
  48:../auxiliary/rfm12-1.1/src/rfm12.c **** #include "rfm12.h"
  49:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  50:../auxiliary/rfm12-1.1/src/rfm12.c **** //for uart debugging
  51:../auxiliary/rfm12-1.1/src/rfm12.c **** #if RFM12_UART_DEBUG
  52:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#include "test-m8/uart.h"
  53:../auxiliary/rfm12-1.1/src/rfm12.c **** #endif
  54:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  55:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  56:../auxiliary/rfm12-1.1/src/rfm12.c **** /************************
  57:../auxiliary/rfm12-1.1/src/rfm12.c ****  * library internal globals
  58:../auxiliary/rfm12-1.1/src/rfm12.c **** */
  59:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  60:../auxiliary/rfm12-1.1/src/rfm12.c **** //! Buffer and status for packet transmission.
  61:../auxiliary/rfm12-1.1/src/rfm12.c **** rf_tx_buffer_t rf_tx_buffer;
  62:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  63:../auxiliary/rfm12-1.1/src/rfm12.c **** //if receive mode is not disabled (default)
  64:../auxiliary/rfm12-1.1/src/rfm12.c **** #if !(RFM12_TRANSMIT_ONLY)
  65:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//! Buffers and status to receive packets.
  66:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rf_rx_buffer_t rf_rx_buffers[2];
  67:../auxiliary/rfm12-1.1/src/rfm12.c **** #endif /* RFM12_USE_WAKEUP_TIMER */
  68:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  69:../auxiliary/rfm12-1.1/src/rfm12.c **** //! Global control and status.
  70:../auxiliary/rfm12-1.1/src/rfm12.c **** rfm12_control_t ctrl;
  71:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  72:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  73:../auxiliary/rfm12-1.1/src/rfm12.c **** /************************
  74:../auxiliary/rfm12-1.1/src/rfm12.c ****  * load other core and external components
  75:../auxiliary/rfm12-1.1/src/rfm12.c ****  * (putting them directly into here allows GCC to optimize better)
  76:../auxiliary/rfm12-1.1/src/rfm12.c **** */
  77:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  78:../auxiliary/rfm12-1.1/src/rfm12.c **** /* include spi functions into here */
  79:../auxiliary/rfm12-1.1/src/rfm12.c **** #include "include/rfm12_spi.c"
  80:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  81:../auxiliary/rfm12-1.1/src/rfm12.c **** /*
  82:../auxiliary/rfm12-1.1/src/rfm12.c ****  * include control / init functions into here
  83:../auxiliary/rfm12-1.1/src/rfm12.c ****  * all of the stuff in there is optional, so there's no code-bloat..
  84:../auxiliary/rfm12-1.1/src/rfm12.c **** */
  85:../auxiliary/rfm12-1.1/src/rfm12.c **** #include "include/rfm12_ctrl.c"
  86:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  87:../auxiliary/rfm12-1.1/src/rfm12.c **** /*
  88:../auxiliary/rfm12-1.1/src/rfm12.c ****  * include extra features here
  89:../auxiliary/rfm12-1.1/src/rfm12.c ****  * all of the stuff in there is optional, so there's no code-bloat..
  90:../auxiliary/rfm12-1.1/src/rfm12.c **** */
  91:../auxiliary/rfm12-1.1/src/rfm12.c **** #include "include/rfm12_extra.c"
  92:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  93:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  94:../auxiliary/rfm12-1.1/src/rfm12.c **** /************************
  95:../auxiliary/rfm12-1.1/src/rfm12.c ****  * Begin of library
  96:../auxiliary/rfm12-1.1/src/rfm12.c **** */
  97:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  98:../auxiliary/rfm12-1.1/src/rfm12.c **** 
  99:../auxiliary/rfm12-1.1/src/rfm12.c **** //! Interrupt handler to handle all transmit and receive data transfers to the rfm12.
 100:../auxiliary/rfm12-1.1/src/rfm12.c **** /** The receiver will generate an interrupt request (IT) for the
 101:../auxiliary/rfm12-1.1/src/rfm12.c **** * microcontroller - by pulling the nIRQ pin low - on the following events:
 102:../auxiliary/rfm12-1.1/src/rfm12.c **** * - The TX register is ready to receive the next byte (RGIT)
 103:../auxiliary/rfm12-1.1/src/rfm12.c **** * - The FIFO has received the preprogrammed amount of bits (FFIT)
 104:../auxiliary/rfm12-1.1/src/rfm12.c **** * - Power-on reset (POR) 
 105:../auxiliary/rfm12-1.1/src/rfm12.c **** * - FIFO overflow (FFOV) / TX register underrun (RGUR) 
 106:../auxiliary/rfm12-1.1/src/rfm12.c **** * - Wake-up timer timeout (WKUP) 
 107:../auxiliary/rfm12-1.1/src/rfm12.c **** * - Negative pulse on the interrupt input pin nINT (EXT) 
 108:../auxiliary/rfm12-1.1/src/rfm12.c **** * - Supply voltage below the preprogrammed value is detected (LBD) 
 109:../auxiliary/rfm12-1.1/src/rfm12.c **** *
 110:../auxiliary/rfm12-1.1/src/rfm12.c **** * The rfm12 status register is read to determine which event has occured.
 111:../auxiliary/rfm12-1.1/src/rfm12.c **** * Reading the status register will clear the event flags.
 112:../auxiliary/rfm12-1.1/src/rfm12.c **** *
 113:../auxiliary/rfm12-1.1/src/rfm12.c **** * The interrupt handles the RGIT and FFIT events by default.
 114:../auxiliary/rfm12-1.1/src/rfm12.c **** * Upon specific configuration of the library the WKUP and LBD events
 115:../auxiliary/rfm12-1.1/src/rfm12.c **** * are handled additionally.
 116:../auxiliary/rfm12-1.1/src/rfm12.c **** *
 117:../auxiliary/rfm12-1.1/src/rfm12.c **** * \see rfm12_control_t, rf_rx_buffer_t and rf_tx_buffer_t
 118:../auxiliary/rfm12-1.1/src/rfm12.c **** */
 119:../auxiliary/rfm12-1.1/src/rfm12.c **** //if polling is used, do not define an interrupt handler, but a polling function
 120:../auxiliary/rfm12-1.1/src/rfm12.c **** #if (RFM12_USE_POLLING)
 121:../auxiliary/rfm12-1.1/src/rfm12.c **** void rfm12_poll(void)
 122:../auxiliary/rfm12-1.1/src/rfm12.c **** #else
 123:../auxiliary/rfm12-1.1/src/rfm12.c **** ISR(RFM12_INT_VECT, ISR_NOBLOCK)
 124:../auxiliary/rfm12-1.1/src/rfm12.c **** #endif
 125:../auxiliary/rfm12-1.1/src/rfm12.c **** {
 432               	.LM54:
 433               	.LFBB8:
 434 00b0 7894      		sei
 435 00b2 1F92      		push r1
 436 00b4 0F92      		push r0
 437 00b6 0FB6      		in r0,__SREG__
 438 00b8 0F92      		push r0
 439 00ba 1124      		clr __zero_reg__
 440 00bc 2F93      		push r18
 441 00be 3F93      		push r19
 442 00c0 4F93      		push r20
 443 00c2 5F93      		push r21
 444 00c4 6F93      		push r22
 445 00c6 7F93      		push r23
 446 00c8 8F93      		push r24
 447 00ca 9F93      		push r25
 448 00cc AF93      		push r26
 449 00ce BF93      		push r27
 450 00d0 CF93      		push r28
 451 00d2 EF93      		push r30
 452 00d4 FF93      		push r31
 453               	/* prologue: Interrupt */
 454               	/* frame size = 0 */
 455               	/* stack size = 16 */
 456               	.L__stack_usage = 16
 126:../auxiliary/rfm12-1.1/src/rfm12.c **** 	RFM12_INT_OFF();
 458               	.LM55:
 459 00d6 E998      		cbi 0x1d,1
 127:../auxiliary/rfm12-1.1/src/rfm12.c **** 	uint8_t status;
 128:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 129:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//if receive mode is not disabled (default)
 130:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if !(RFM12_TRANSMIT_ONLY)
 131:../auxiliary/rfm12-1.1/src/rfm12.c **** 		static uint8_t checksum; //static local variables produce smaller code size than globals
 132:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif /* !(RFM12_TRANSMIT_ONLY) */
 133:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 134:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//first we read the first byte of the status register
 135:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//to get the interrupt flags
 136:../auxiliary/rfm12-1.1/src/rfm12.c **** 	status = rfm12_read_int_flags_inline();
 461               	.LM56:
 462 00d8 00D0      		rcall rfm12_read_int_flags_inline
 137:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 138:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//low battery detector feature
 139:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if RFM12_LOW_BATT_DETECTOR
 140:../auxiliary/rfm12-1.1/src/rfm12.c **** 	if(status & (RFM12_STATUS_LBD>>8))
 141:../auxiliary/rfm12-1.1/src/rfm12.c **** 	{
 142:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//debug
 143:../auxiliary/rfm12-1.1/src/rfm12.c **** 		#if RFM12_UART_DEBUG >= 2
 144:../auxiliary/rfm12-1.1/src/rfm12.c **** 			uart_putc('L');
 145:../auxiliary/rfm12-1.1/src/rfm12.c **** 		#endif
 146:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 147:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//set status variable to low battery
 148:../auxiliary/rfm12-1.1/src/rfm12.c **** 		ctrl.low_batt = RFM12_BATT_LOW;
 149:../auxiliary/rfm12-1.1/src/rfm12.c **** 	}
 150:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif /* RFM12_LOW_BATT_DETECTOR */	
 151:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 152:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//wakeup timer feature
 153:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if RFM12_USE_WAKEUP_TIMER
 154:../auxiliary/rfm12-1.1/src/rfm12.c **** 	if(status & (RFM12_STATUS_WKUP>>8))
 155:../auxiliary/rfm12-1.1/src/rfm12.c **** 	{
 156:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//debug
 157:../auxiliary/rfm12-1.1/src/rfm12.c **** 		#if RFM12_UART_DEBUG >= 2
 158:../auxiliary/rfm12-1.1/src/rfm12.c **** 			uart_putc('W');
 159:../auxiliary/rfm12-1.1/src/rfm12.c **** 		#endif
 160:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 161:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//restart the wakeup timer by toggling the bit on and off
 162:../auxiliary/rfm12-1.1/src/rfm12.c **** 		rfm12_data(ctrl.pwrmgt_shadow & ~RFM12_PWRMGT_EW);
 163:../auxiliary/rfm12-1.1/src/rfm12.c **** 		rfm12_data(ctrl.pwrmgt_shadow);
 164:../auxiliary/rfm12-1.1/src/rfm12.c **** 	}
 165:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif /* RFM12_USE_WAKEUP_TIMER */
 166:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 167:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//check if the fifo interrupt occurred
 168:../auxiliary/rfm12-1.1/src/rfm12.c **** 	if(!(status & (RFM12_STATUS_FFIT>>8)))
 464               	.LM57:
 465 00da 87FD      		sbrc r24,7
 466 00dc 00C0      		rjmp .L36
 467               	.L25:
 169:../auxiliary/rfm12-1.1/src/rfm12.c **** 		goto END;
 170:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 171:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//see what we have to do (start rx, rx or tx)
 172:../auxiliary/rfm12-1.1/src/rfm12.c **** 	switch(ctrl.rfm12_state)
 173:../auxiliary/rfm12-1.1/src/rfm12.c **** 	{			
 174:../auxiliary/rfm12-1.1/src/rfm12.c **** 		case STATE_RX_IDLE:
 175:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//if receive mode is not disabled (default)
 176:../auxiliary/rfm12-1.1/src/rfm12.c **** 			#if !(RFM12_TRANSMIT_ONLY)
 177:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//init the bytecounter - remember, we will read the length byte, so this must be 1
 178:../auxiliary/rfm12-1.1/src/rfm12.c **** 				ctrl.bytecount = 1;
 179:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 180:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//read the length byte,  and write it to the checksum
 181:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//remember, the first byte is the length byte			
 182:../auxiliary/rfm12-1.1/src/rfm12.c **** 				checksum = rfm12_read_fifo_inline();
 183:../auxiliary/rfm12-1.1/src/rfm12.c **** 				
 184:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//add the packet overhead and store it into a working variable
 185:../auxiliary/rfm12-1.1/src/rfm12.c **** 				ctrl.num_bytes = checksum + PACKET_OVERHEAD;
 186:../auxiliary/rfm12-1.1/src/rfm12.c **** 				
 187:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//debug
 188:../auxiliary/rfm12-1.1/src/rfm12.c **** 				#if RFM12_UART_DEBUG >= 2
 189:../auxiliary/rfm12-1.1/src/rfm12.c **** 					uart_putc('I');
 190:../auxiliary/rfm12-1.1/src/rfm12.c **** 					uart_putc(checksum);
 191:../auxiliary/rfm12-1.1/src/rfm12.c **** 				#endif
 192:../auxiliary/rfm12-1.1/src/rfm12.c **** 				
 193:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//see whether our buffer is free
 194:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//FIXME: put this into global statekeeping struct, the free state can be set by the function wh
 195:../auxiliary/rfm12-1.1/src/rfm12.c **** 				if(ctrl.rf_buffer_in->status == STATUS_FREE)
 196:../auxiliary/rfm12-1.1/src/rfm12.c **** 				{
 197:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//the current receive buffer is empty, so we start receiving
 198:../auxiliary/rfm12-1.1/src/rfm12.c **** 					ctrl.rfm12_state = STATE_RX_ACTIVE;
 199:../auxiliary/rfm12-1.1/src/rfm12.c **** 				
 200:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//store the received length into the packet buffer
 201:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//FIXME:  why the hell do we need this?!
 202:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//in principle, the length is stored alongside with the buffer.. the only problem is, that the
 203:../auxiliary/rfm12-1.1/src/rfm12.c **** 					ctrl.rf_buffer_in->len = checksum;
 204:../auxiliary/rfm12-1.1/src/rfm12.c **** 					
 205:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//end the interrupt without resetting the fifo
 206:../auxiliary/rfm12-1.1/src/rfm12.c **** 					goto END;
 207:../auxiliary/rfm12-1.1/src/rfm12.c **** 				}
 208:../auxiliary/rfm12-1.1/src/rfm12.c **** 			
 209:../auxiliary/rfm12-1.1/src/rfm12.c **** 				/* if we're here, the buffer is full, so we ignore this transmission by resetting the fifo (at 
 210:../auxiliary/rfm12-1.1/src/rfm12.c **** 			#endif /* !(RFM12_TRANSMIT_ONLY) */
 211:../auxiliary/rfm12-1.1/src/rfm12.c **** 			break;
 212:../auxiliary/rfm12-1.1/src/rfm12.c **** 			
 213:../auxiliary/rfm12-1.1/src/rfm12.c **** 		case STATE_RX_ACTIVE:
 214:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//if receive mode is not disabled (default)
 215:../auxiliary/rfm12-1.1/src/rfm12.c **** 			#if !(RFM12_TRANSMIT_ONLY)
 216:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//check if transmission is complete
 217:../auxiliary/rfm12-1.1/src/rfm12.c **** 				if(ctrl.bytecount < ctrl.num_bytes)
 218:../auxiliary/rfm12-1.1/src/rfm12.c **** 				{
 219:../auxiliary/rfm12-1.1/src/rfm12.c **** 					uint8_t data;
 220:../auxiliary/rfm12-1.1/src/rfm12.c **** 					
 221:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//read a byte
 222:../auxiliary/rfm12-1.1/src/rfm12.c **** 					data = rfm12_read_fifo_inline();
 223:../auxiliary/rfm12-1.1/src/rfm12.c **** 					
 224:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//debug
 225:../auxiliary/rfm12-1.1/src/rfm12.c **** 					#if RFM12_UART_DEBUG >= 2
 226:../auxiliary/rfm12-1.1/src/rfm12.c **** 						uart_putc('R');
 227:../auxiliary/rfm12-1.1/src/rfm12.c **** 						uart_putc(data);
 228:../auxiliary/rfm12-1.1/src/rfm12.c **** 					#endif
 229:../auxiliary/rfm12-1.1/src/rfm12.c **** 					
 230:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//xor the remaining bytes onto the checksum
 231:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//note: only the header will be effectively checked
 232:../auxiliary/rfm12-1.1/src/rfm12.c **** 					checksum ^= data;
 233:../auxiliary/rfm12-1.1/src/rfm12.c **** 					
 234:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//put next byte into buffer, if there is enough space
 235:../auxiliary/rfm12-1.1/src/rfm12.c **** 					if(ctrl.bytecount < (RFM12_RX_BUFFER_SIZE + 3))
 236:../auxiliary/rfm12-1.1/src/rfm12.c **** 					{
 237:../auxiliary/rfm12-1.1/src/rfm12.c **** 						//hackhack: begin writing to struct at offsetof len
 238:../auxiliary/rfm12-1.1/src/rfm12.c **** 						(& ctrl.rf_buffer_in->len)[ctrl.bytecount] = data;
 239:../auxiliary/rfm12-1.1/src/rfm12.c **** 					}
 240:../auxiliary/rfm12-1.1/src/rfm12.c **** 					
 241:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//check header against checksum
 242:../auxiliary/rfm12-1.1/src/rfm12.c **** 					if (ctrl.bytecount == 2 && checksum != 0xff)
 243:../auxiliary/rfm12-1.1/src/rfm12.c **** 					{
 244:../auxiliary/rfm12-1.1/src/rfm12.c **** 						//if the checksum does not match, reset the fifo
 245:../auxiliary/rfm12-1.1/src/rfm12.c **** 						break;
 246:../auxiliary/rfm12-1.1/src/rfm12.c **** 					}
 247:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 248:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//increment bytecount
 249:../auxiliary/rfm12-1.1/src/rfm12.c **** 					ctrl.bytecount++;
 250:../auxiliary/rfm12-1.1/src/rfm12.c **** 					
 251:../auxiliary/rfm12-1.1/src/rfm12.c **** 					//end the interrupt without resetting the fifo
 252:../auxiliary/rfm12-1.1/src/rfm12.c **** 					goto END;
 253:../auxiliary/rfm12-1.1/src/rfm12.c **** 				}
 254:../auxiliary/rfm12-1.1/src/rfm12.c **** 				
 255:../auxiliary/rfm12-1.1/src/rfm12.c **** 				/* if we're here, receiving is done */
 256:../auxiliary/rfm12-1.1/src/rfm12.c **** 				/* the fifo will be reset at the end of the function */
 257:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 258:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//debug
 259:../auxiliary/rfm12-1.1/src/rfm12.c **** 				#if RFM12_UART_DEBUG >= 2
 260:../auxiliary/rfm12-1.1/src/rfm12.c **** 					uart_putc('D');
 261:../auxiliary/rfm12-1.1/src/rfm12.c **** 				#endif
 262:../auxiliary/rfm12-1.1/src/rfm12.c **** 				
 263:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//indicate that the buffer is ready to be used
 264:../auxiliary/rfm12-1.1/src/rfm12.c **** 				ctrl.rf_buffer_in->status = STATUS_COMPLETE;
 265:../auxiliary/rfm12-1.1/src/rfm12.c **** 				
 266:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//switch to other buffer
 267:../auxiliary/rfm12-1.1/src/rfm12.c **** 				ctrl.buffer_in_num = (ctrl.buffer_in_num + 1) % 2;
 268:../auxiliary/rfm12-1.1/src/rfm12.c **** 				ctrl.rf_buffer_in = &rf_rx_buffers[ctrl.buffer_in_num];
 269:../auxiliary/rfm12-1.1/src/rfm12.c **** 			#endif /* !(RFM12_TRANSMIT_ONLY) */
 270:../auxiliary/rfm12-1.1/src/rfm12.c **** 			break;
 271:../auxiliary/rfm12-1.1/src/rfm12.c **** 			
 272:../auxiliary/rfm12-1.1/src/rfm12.c **** 		case STATE_TX:
 273:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//debug
 274:../auxiliary/rfm12-1.1/src/rfm12.c **** 			#if RFM12_UART_DEBUG >= 2
 275:../auxiliary/rfm12-1.1/src/rfm12.c **** 				uart_putc('T');
 276:../auxiliary/rfm12-1.1/src/rfm12.c **** 			#endif
 277:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 278:../auxiliary/rfm12-1.1/src/rfm12.c **** 			if(ctrl.bytecount < ctrl.num_bytes)
 279:../auxiliary/rfm12-1.1/src/rfm12.c **** 			{
 280:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//load the next byte from our buffer struct.
 281:../auxiliary/rfm12-1.1/src/rfm12.c **** 				rfm12_data_inline( (RFM12_CMD_TX>>8), rf_tx_buffer.sync[ctrl.bytecount++]);
 282:../auxiliary/rfm12-1.1/src/rfm12.c **** 							
 283:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//end the interrupt without resetting the fifo
 284:../auxiliary/rfm12-1.1/src/rfm12.c **** 				goto END;
 285:../auxiliary/rfm12-1.1/src/rfm12.c **** 			}
 286:../auxiliary/rfm12-1.1/src/rfm12.c **** 			
 287:../auxiliary/rfm12-1.1/src/rfm12.c **** 			/* if we're here, we're finished transmitting the bytes */
 288:../auxiliary/rfm12-1.1/src/rfm12.c **** 			/* the fifo will be reset at the end of the function */
 289:../auxiliary/rfm12-1.1/src/rfm12.c **** 			
 290:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//flag the buffer as free again
 291:../auxiliary/rfm12-1.1/src/rfm12.c **** 			ctrl.txstate = STATUS_FREE;
 292:../auxiliary/rfm12-1.1/src/rfm12.c **** 			
 293:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//wakeup timer feature
 294:../auxiliary/rfm12-1.1/src/rfm12.c **** 			#if RFM12_USE_WAKEUP_TIMER
 295:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//clear wakeup timer once
 296:../auxiliary/rfm12-1.1/src/rfm12.c **** 				rfm12_data(ctrl.pwrmgt_shadow & ~RFM12_PWRMGT_EW);
 297:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//set shadow register to default receive state
 298:../auxiliary/rfm12-1.1/src/rfm12.c **** 				//the define correctly handles the transmit only mode
 299:../auxiliary/rfm12-1.1/src/rfm12.c **** 				ctrl.pwrmgt_shadow = (RFM12_CMD_PWRMGT | PWRMGT_RECEIVE);							
 300:../auxiliary/rfm12-1.1/src/rfm12.c **** 			#endif /* RFM12_USE_WAKEUP_TIMER */
 301:../auxiliary/rfm12-1.1/src/rfm12.c **** 				
 302:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//turn off the transmitter and enable receiver
 303:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//the receiver is not enabled in transmit only mode
 304:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//if the wakeup timer is used, this will re-enable the wakeup timer bit
 305:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//the magic is done via defines
 306:../auxiliary/rfm12-1.1/src/rfm12.c **** 			rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_RECEIVE);
 307:../auxiliary/rfm12-1.1/src/rfm12.c **** 			
 308:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//load a dummy byte to clear int status
 309:../auxiliary/rfm12-1.1/src/rfm12.c **** 			rfm12_data_inline( (RFM12_CMD_TX>>8), 0xaa);
 310:../auxiliary/rfm12-1.1/src/rfm12.c **** 			break;			
 311:../auxiliary/rfm12-1.1/src/rfm12.c **** 	}
 312:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 313:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//set the state machine to idle
 314:../auxiliary/rfm12-1.1/src/rfm12.c **** 	ctrl.rfm12_state = STATE_RX_IDLE;
 315:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 316:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//reset the receiver fifo, if receive mode is not disabled (default)
 317:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if !(RFM12_TRANSMIT_ONLY)
 318:../auxiliary/rfm12-1.1/src/rfm12.c **** 		rfm12_data_inline(RFM12_CMD_FIFORESET>>8, CLEAR_FIFO_INLINE);
 319:../auxiliary/rfm12-1.1/src/rfm12.c **** 		rfm12_data_inline(RFM12_CMD_FIFORESET>>8, ACCEPT_DATA_INLINE);
 320:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif /* !(RFM12_TRANSMIT_ONLY) */	
 321:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 322:../auxiliary/rfm12-1.1/src/rfm12.c **** 	END:
 323:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//turn the int back on
 324:../auxiliary/rfm12-1.1/src/rfm12.c **** 	RFM12_INT_ON();
 469               	.LM58:
 470 00de E99A      		sbi 0x1d,1
 471               	/* epilogue start */
 325:../auxiliary/rfm12-1.1/src/rfm12.c **** }
 473               	.LM59:
 474 00e0 FF91      		pop r31
 475 00e2 EF91      		pop r30
 476 00e4 CF91      		pop r28
 477 00e6 BF91      		pop r27
 478 00e8 AF91      		pop r26
 479 00ea 9F91      		pop r25
 480 00ec 8F91      		pop r24
 481 00ee 7F91      		pop r23
 482 00f0 6F91      		pop r22
 483 00f2 5F91      		pop r21
 484 00f4 4F91      		pop r20
 485 00f6 3F91      		pop r19
 486 00f8 2F91      		pop r18
 487 00fa 0F90      		pop r0
 488 00fc 0FBE      		out __SREG__,r0
 489 00fe 0F90      		pop r0
 490 0100 1F90      		pop r1
 491 0102 1895      		reti
 492               	.L36:
 172:../auxiliary/rfm12-1.1/src/rfm12.c **** 	switch(ctrl.rfm12_state)
 494               	.LM60:
 495 0104 8091 0000 		lds r24,ctrl
 496 0108 8130      		cpi r24,lo8(1)
 497 010a 01F0      		breq .L27
 498 010c 00F0      		brlo .L28
 499 010e 8230      		cpi r24,lo8(2)
 500 0110 01F4      		brne .L26
 278:../auxiliary/rfm12-1.1/src/rfm12.c **** 			if(ctrl.bytecount < ctrl.num_bytes)
 502               	.LM61:
 503 0112 E091 0000 		lds r30,ctrl+3
 504 0116 8091 0000 		lds r24,ctrl+2
 505 011a E817      		cp r30,r24
 506 011c 00F4      		brsh .+2
 507 011e 00C0      		rjmp .L37
 291:../auxiliary/rfm12-1.1/src/rfm12.c **** 			ctrl.txstate = STATUS_FREE;
 509               	.LM62:
 510 0120 1092 0000 		sts ctrl+1,__zero_reg__
 306:../auxiliary/rfm12-1.1/src/rfm12.c **** 			rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_RECEIVE);
 512               	.LM63:
 513 0124 81E8      		ldi r24,lo8(-127)
 514 0126 92E8      		ldi r25,lo8(-126)
 515 0128 00D0      		rcall rfm12_data
 309:../auxiliary/rfm12-1.1/src/rfm12.c **** 			rfm12_data_inline( (RFM12_CMD_TX>>8), 0xaa);
 517               	.LM64:
 518 012a 6AEA      		ldi r22,lo8(-86)
 519 012c 88EB      		ldi r24,lo8(-72)
 520 012e 00D0      		rcall rfm12_data_inline
 521               	.L26:
 314:../auxiliary/rfm12-1.1/src/rfm12.c **** 	ctrl.rfm12_state = STATE_RX_IDLE;
 523               	.LM65:
 524 0130 1092 0000 		sts ctrl,__zero_reg__
 318:../auxiliary/rfm12-1.1/src/rfm12.c **** 		rfm12_data_inline(RFM12_CMD_FIFORESET>>8, CLEAR_FIFO_INLINE);
 526               	.LM66:
 527 0134 61E8      		ldi r22,lo8(-127)
 528 0136 8AEC      		ldi r24,lo8(-54)
 529 0138 00D0      		rcall rfm12_data_inline
 319:../auxiliary/rfm12-1.1/src/rfm12.c **** 		rfm12_data_inline(RFM12_CMD_FIFORESET>>8, ACCEPT_DATA_INLINE);
 531               	.LM67:
 532 013a 63E8      		ldi r22,lo8(-125)
 533 013c 8AEC      		ldi r24,lo8(-54)
 534 013e 00D0      		rcall rfm12_data_inline
 535 0140 00C0      		rjmp .L25
 536               	.L28:
 178:../auxiliary/rfm12-1.1/src/rfm12.c **** 				ctrl.bytecount = 1;
 538               	.LM68:
 539 0142 C1E0      		ldi r28,lo8(1)
 540 0144 C093 0000 		sts ctrl+3,r28
 182:../auxiliary/rfm12-1.1/src/rfm12.c **** 				checksum = rfm12_read_fifo_inline();
 542               	.LM69:
 543 0148 00D0      		rcall rfm12_read_fifo_inline
 544 014a 8093 0000 		sts checksum.1849,r24
 185:../auxiliary/rfm12-1.1/src/rfm12.c **** 				ctrl.num_bytes = checksum + PACKET_OVERHEAD;
 546               	.LM70:
 547 014e 93E0      		ldi r25,lo8(3)
 548 0150 980F      		add r25,r24
 549 0152 9093 0000 		sts ctrl+2,r25
 195:../auxiliary/rfm12-1.1/src/rfm12.c **** 				if(ctrl.rf_buffer_in->status == STATUS_FREE)
 551               	.LM71:
 552 0156 E091 0000 		lds r30,ctrl+4
 553 015a F091 0000 		lds r31,ctrl+4+1
 554 015e 9081      		ld r25,Z
 555 0160 9111      		cpse r25,__zero_reg__
 556 0162 00C0      		rjmp .L26
 198:../auxiliary/rfm12-1.1/src/rfm12.c **** 					ctrl.rfm12_state = STATE_RX_ACTIVE;
 558               	.LM72:
 559 0164 C093 0000 		sts ctrl,r28
 203:../auxiliary/rfm12-1.1/src/rfm12.c **** 					ctrl.rf_buffer_in->len = checksum;
 561               	.LM73:
 562 0168 8183      		std Z+1,r24
 206:../auxiliary/rfm12-1.1/src/rfm12.c **** 					goto END;
 564               	.LM74:
 565 016a 00C0      		rjmp .L25
 566               	.L27:
 217:../auxiliary/rfm12-1.1/src/rfm12.c **** 				if(ctrl.bytecount < ctrl.num_bytes)
 568               	.LM75:
 569 016c 9091 0000 		lds r25,ctrl+3
 570 0170 8091 0000 		lds r24,ctrl+2
 571 0174 9817      		cp r25,r24
 572 0176 00F0      		brlo .L38
 264:../auxiliary/rfm12-1.1/src/rfm12.c **** 				ctrl.rf_buffer_in->status = STATUS_COMPLETE;
 574               	.LM76:
 575 0178 E091 0000 		lds r30,ctrl+4
 576 017c F091 0000 		lds r31,ctrl+4+1
 577 0180 82E0      		ldi r24,lo8(2)
 578 0182 8083      		st Z,r24
 267:../auxiliary/rfm12-1.1/src/rfm12.c **** 				ctrl.buffer_in_num = (ctrl.buffer_in_num + 1) % 2;
 580               	.LM77:
 581 0184 8091 0000 		lds r24,ctrl+8
 582 0188 90E0      		ldi r25,0
 583 018a 0196      		adiw r24,1
 584 018c 8170      		andi r24,1
 585 018e 9927      		clr r25
 586 0190 8093 0000 		sts ctrl+8,r24
 268:../auxiliary/rfm12-1.1/src/rfm12.c **** 				ctrl.rf_buffer_in = &rf_rx_buffers[ctrl.buffer_in_num];
 588               	.LM78:
 589 0194 42E2      		ldi r20,lo8(34)
 590 0196 489F      		mul r20,r24
 591 0198 9001      		movw r18,r0
 592 019a 499F      		mul r20,r25
 593 019c 300D      		add r19,r0
 594 019e 1124      		clr __zero_reg__
 595 01a0 2050      		subi r18,lo8(-(rf_rx_buffers))
 596 01a2 3040      		sbci r19,hi8(-(rf_rx_buffers))
 597 01a4 3093 0000 		sts ctrl+4+1,r19
 598 01a8 2093 0000 		sts ctrl+4,r18
 270:../auxiliary/rfm12-1.1/src/rfm12.c **** 			break;
 600               	.LM79:
 601 01ac 00C0      		rjmp .L26
 602               	.L37:
 281:../auxiliary/rfm12-1.1/src/rfm12.c **** 				rfm12_data_inline( (RFM12_CMD_TX>>8), rf_tx_buffer.sync[ctrl.bytecount++]);
 604               	.LM80:
 605 01ae 81E0      		ldi r24,lo8(1)
 606 01b0 8E0F      		add r24,r30
 607 01b2 8093 0000 		sts ctrl+3,r24
 608 01b6 F0E0      		ldi r31,0
 609 01b8 E050      		subi r30,lo8(-(rf_tx_buffer))
 610 01ba F040      		sbci r31,hi8(-(rf_tx_buffer))
 611 01bc 6081      		ld r22,Z
 612 01be 88EB      		ldi r24,lo8(-72)
 613 01c0 00D0      		rcall rfm12_data_inline
 284:../auxiliary/rfm12-1.1/src/rfm12.c **** 				goto END;
 615               	.LM81:
 616 01c2 00C0      		rjmp .L25
 617               	.L38:
 618               	.LBB22:
 222:../auxiliary/rfm12-1.1/src/rfm12.c **** 					data = rfm12_read_fifo_inline();
 620               	.LM82:
 621 01c4 00D0      		rcall rfm12_read_fifo_inline
 232:../auxiliary/rfm12-1.1/src/rfm12.c **** 					checksum ^= data;
 623               	.LM83:
 624 01c6 9091 0000 		lds r25,checksum.1849
 625 01ca 9827      		eor r25,r24
 626 01cc 9093 0000 		sts checksum.1849,r25
 235:../auxiliary/rfm12-1.1/src/rfm12.c **** 					if(ctrl.bytecount < (RFM12_RX_BUFFER_SIZE + 3))
 628               	.LM84:
 629 01d0 2091 0000 		lds r18,ctrl+3
 630 01d4 2132      		cpi r18,lo8(33)
 631 01d6 00F4      		brsh .L32
 238:../auxiliary/rfm12-1.1/src/rfm12.c **** 						(& ctrl.rf_buffer_in->len)[ctrl.bytecount] = data;
 633               	.LM85:
 634 01d8 E091 0000 		lds r30,ctrl+4
 635 01dc F091 0000 		lds r31,ctrl+4+1
 636 01e0 E20F      		add r30,r18
 637 01e2 F11D      		adc r31,__zero_reg__
 638 01e4 8183      		std Z+1,r24
 639 01e6 2091 0000 		lds r18,ctrl+3
 242:../auxiliary/rfm12-1.1/src/rfm12.c **** 					if (ctrl.bytecount == 2 && checksum != 0xff)
 641               	.LM86:
 642 01ea 2230      		cpi r18,lo8(2)
 643 01ec 01F4      		brne .L32
 242:../auxiliary/rfm12-1.1/src/rfm12.c **** 					if (ctrl.bytecount == 2 && checksum != 0xff)
 645               	.LM87:
 646 01ee 9F3F      		cpi r25,lo8(-1)
 647 01f0 01F0      		breq .+2
 648 01f2 00C0      		rjmp .L26
 649               	.L32:
 249:../auxiliary/rfm12-1.1/src/rfm12.c **** 					ctrl.bytecount++;
 651               	.LM88:
 652 01f4 2F5F      		subi r18,lo8(-(1))
 653 01f6 2093 0000 		sts ctrl+3,r18
 252:../auxiliary/rfm12-1.1/src/rfm12.c **** 					goto END;
 655               	.LM89:
 656 01fa 00C0      		rjmp .L25
 657               	.LBE22:
 665               	.Lscope8:
 667               		.stabd	78,0,0
 669               	.global	rfm12_tick
 671               	rfm12_tick:
 672               		.stabd	46,0,0
 326:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 327:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 328:../auxiliary/rfm12-1.1/src/rfm12.c **** //! The tick function implements collision avoidance and initiates transmissions.
 329:../auxiliary/rfm12-1.1/src/rfm12.c **** /** This function has to be called periodically.
 330:../auxiliary/rfm12-1.1/src/rfm12.c **** * It will read the rfm12 status register to check if a carrier is being received,
 331:../auxiliary/rfm12-1.1/src/rfm12.c **** * which would indicate activity on the chosen radio channel. \n
 332:../auxiliary/rfm12-1.1/src/rfm12.c **** * If there has been no activity for long enough, the channel is believed to be free.
 333:../auxiliary/rfm12-1.1/src/rfm12.c **** *
 334:../auxiliary/rfm12-1.1/src/rfm12.c **** * When there is a packet waiting for transmission and the collision avoidance
 335:../auxiliary/rfm12-1.1/src/rfm12.c **** * algorithm indicates that the air is free, then the interrupt control variables are
 336:../auxiliary/rfm12-1.1/src/rfm12.c **** * setup for packet transmission and the rfm12 is switched to transmit mode.
 337:../auxiliary/rfm12-1.1/src/rfm12.c **** * This function also fills the rfm12 tx fifo with a preamble.
 338:../auxiliary/rfm12-1.1/src/rfm12.c **** *
 339:../auxiliary/rfm12-1.1/src/rfm12.c **** * \warning Warning, if you do not call this function periodically, then no packet will get transmit
 340:../auxiliary/rfm12-1.1/src/rfm12.c **** * \see rfm12_tx() and rfm12_start_tx()
 341:../auxiliary/rfm12-1.1/src/rfm12.c **** */
 342:../auxiliary/rfm12-1.1/src/rfm12.c **** void rfm12_tick(void)
 343:../auxiliary/rfm12-1.1/src/rfm12.c **** {	
 674               	.LM90:
 675               	.LFBB9:
 676               	/* prologue: function */
 677               	/* frame size = 0 */
 678               	/* stack size = 0 */
 679               	.L__stack_usage = 0
 344:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//collision detection is enabled by default
 345:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if !(RFM12_NOCOLLISIONDETECTION)
 346:../auxiliary/rfm12-1.1/src/rfm12.c **** 		uint16_t status;
 347:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 348:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//start with a channel free count of 16, this is necessary for the ASK receive feature to work
 349:../auxiliary/rfm12-1.1/src/rfm12.c **** 		static uint8_t channel_free_count = 16; //static local variables produce smaller code size than g
 350:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif
 351:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 352:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//debug
 353:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if RFM12_UART_DEBUG
 354:../auxiliary/rfm12-1.1/src/rfm12.c **** 		static uint8_t oldstate;
 355:../auxiliary/rfm12-1.1/src/rfm12.c **** 		uint8_t state = ctrl.rfm12_state;
 356:../auxiliary/rfm12-1.1/src/rfm12.c **** 		if (oldstate != state)
 357:../auxiliary/rfm12-1.1/src/rfm12.c **** 		{
 358:../auxiliary/rfm12-1.1/src/rfm12.c **** 			uart_putstr ("mode change: ");
 359:../auxiliary/rfm12-1.1/src/rfm12.c **** 			switch (state)
 360:../auxiliary/rfm12-1.1/src/rfm12.c **** 			{
 361:../auxiliary/rfm12-1.1/src/rfm12.c **** 				case STATE_RX_IDLE:
 362:../auxiliary/rfm12-1.1/src/rfm12.c **** 					uart_putc ('i');
 363:../auxiliary/rfm12-1.1/src/rfm12.c **** 					break;
 364:../auxiliary/rfm12-1.1/src/rfm12.c **** 				case STATE_RX_ACTIVE:
 365:../auxiliary/rfm12-1.1/src/rfm12.c **** 					uart_putc ('r');
 366:../auxiliary/rfm12-1.1/src/rfm12.c **** 					break;
 367:../auxiliary/rfm12-1.1/src/rfm12.c **** 				case STATE_TX:
 368:../auxiliary/rfm12-1.1/src/rfm12.c **** 					uart_putc ('t');
 369:../auxiliary/rfm12-1.1/src/rfm12.c **** 					break;
 370:../auxiliary/rfm12-1.1/src/rfm12.c **** 				default:
 371:../auxiliary/rfm12-1.1/src/rfm12.c **** 					uart_putc ('?');
 372:../auxiliary/rfm12-1.1/src/rfm12.c **** 			}
 373:../auxiliary/rfm12-1.1/src/rfm12.c **** 			uart_putstr ("\r\n");
 374:../auxiliary/rfm12-1.1/src/rfm12.c **** 			oldstate = state;
 375:../auxiliary/rfm12-1.1/src/rfm12.c **** 		}
 376:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif
 377:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 378:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//don't disturb RFM12 if transmitting or receiving
 379:../auxiliary/rfm12-1.1/src/rfm12.c **** 	if(ctrl.rfm12_state != STATE_RX_IDLE)
 681               	.LM91:
 682 01fc 8091 0000 		lds r24,ctrl
 683 0200 8111      		cpse r24,__zero_reg__
 684 0202 00C0      		rjmp .L39
 380:../auxiliary/rfm12-1.1/src/rfm12.c **** 	{
 381:../auxiliary/rfm12-1.1/src/rfm12.c **** 		return;
 382:../auxiliary/rfm12-1.1/src/rfm12.c **** 	}	
 383:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 384:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//collision detection is enabled by default
 385:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if !(RFM12_NOCOLLISIONDETECTION)
 386:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//disable the interrupt (as we're working directly with the transceiver now)
 387:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//hint: we could be losing an interrupt here 
 388:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//solutions: check status flag if int is set, launch int and exit ... OR implement packet retrans
 389:../auxiliary/rfm12-1.1/src/rfm12.c **** 		RFM12_INT_OFF();	
 390:../auxiliary/rfm12-1.1/src/rfm12.c **** 		status = rfm12_read(RFM12_CMD_STATUS);
 391:../auxiliary/rfm12-1.1/src/rfm12.c **** 		RFM12_INT_ON();
 392:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 393:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//check if we see a carrier
 394:../auxiliary/rfm12-1.1/src/rfm12.c **** 		if(status & RFM12_STATUS_RSSI)
 395:../auxiliary/rfm12-1.1/src/rfm12.c **** 		{
 396:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//yes: reset free counter and return
 397:../auxiliary/rfm12-1.1/src/rfm12.c **** 			channel_free_count = CHANNEL_FREE_TIME;
 398:../auxiliary/rfm12-1.1/src/rfm12.c **** 			return;
 399:../auxiliary/rfm12-1.1/src/rfm12.c **** 		}
 400:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 401:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//no: decrement counter
 402:../auxiliary/rfm12-1.1/src/rfm12.c **** 		channel_free_count--;
 403:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 404:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//is the channel free long enough ?
 405:../auxiliary/rfm12-1.1/src/rfm12.c **** 		if(channel_free_count != 0)
 406:../auxiliary/rfm12-1.1/src/rfm12.c **** 		{
 407:../auxiliary/rfm12-1.1/src/rfm12.c **** 			return;
 408:../auxiliary/rfm12-1.1/src/rfm12.c **** 		}
 409:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 410:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//reset the channel free count for the next decrement (during the next call..)
 411:../auxiliary/rfm12-1.1/src/rfm12.c **** 		channel_free_count = 1;
 412:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif	
 413:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 414:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//do we have something to transmit?
 415:../auxiliary/rfm12-1.1/src/rfm12.c **** 	if(ctrl.txstate == STATUS_OCCUPIED)
 686               	.LM92:
 687 0204 8091 0000 		lds r24,ctrl+1
 688 0208 8130      		cpi r24,lo8(1)
 689 020a 01F0      		breq .L41
 690               	.L39:
 691 020c 0895      		ret
 692               	.L41:
 416:../auxiliary/rfm12-1.1/src/rfm12.c **** 	{ //yes: start transmitting
 417:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//disable the interrupt (as we're working directly with the transceiver now)
 418:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//hint: we could be losing an interrupt here, too
 419:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//we could also disturb an ongoing reception,
 420:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//if it just started some cpu cycles ago 
 421:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//(as the check for this case is some lines (cpu cycles) above)
 422:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//anyhow, we MUST transmit at some point...
 423:../auxiliary/rfm12-1.1/src/rfm12.c **** 		RFM12_INT_OFF();
 694               	.LM93:
 695 020e E998      		cbi 0x1d,1
 424:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 425:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//disable receiver - if you don't do this, tx packets will get lost
 426:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//as the fifo seems to be in use by the receiver
 427:../auxiliary/rfm12-1.1/src/rfm12.c **** 		rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_DEFAULT);
 697               	.LM94:
 698 0210 81E0      		ldi r24,lo8(1)
 699 0212 92E8      		ldi r25,lo8(-126)
 700 0214 00D0      		rcall rfm12_data
 428:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 429:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//calculate number of bytes to be sent by ISR
 430:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//2 sync bytes + len byte + type byte + checksum + message length + 1 dummy byte
 431:../auxiliary/rfm12-1.1/src/rfm12.c **** 		ctrl.num_bytes = rf_tx_buffer.len + 6;
 702               	.LM95:
 703 0216 8091 0000 		lds r24,rf_tx_buffer+2
 704 021a 8A5F      		subi r24,lo8(-(6))
 705 021c 8093 0000 		sts ctrl+2,r24
 432:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 433:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//reset byte sent counter
 434:../auxiliary/rfm12-1.1/src/rfm12.c **** 		ctrl.bytecount = 0;
 707               	.LM96:
 708 0220 1092 0000 		sts ctrl+3,__zero_reg__
 435:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 436:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//set mode for interrupt handler
 437:../auxiliary/rfm12-1.1/src/rfm12.c **** 		ctrl.rfm12_state = STATE_TX;
 710               	.LM97:
 711 0224 82E0      		ldi r24,lo8(2)
 712 0226 8093 0000 		sts ctrl,r24
 438:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 439:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//wakeup timer feature
 440:../auxiliary/rfm12-1.1/src/rfm12.c **** 		#if RFM12_USE_WAKEUP_TIMER		
 441:../auxiliary/rfm12-1.1/src/rfm12.c **** 			ctrl.pwrmgt_shadow = (RFM12_CMD_PWRMGT | PWRMGT_DEFAULT | RFM12_PWRMGT_ET);
 442:../auxiliary/rfm12-1.1/src/rfm12.c **** 		#endif /* RFM12_USE_WAKEUP_TIMER */
 443:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 444:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//fill 2byte 0xAA preamble into data register
 445:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//the preamble helps the receivers AFC circuit to lock onto the exact frequency
 446:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//(hint: the tx FIFO [if el is enabled] is two staged, so we can safely write 2 bytes before star
 447:../auxiliary/rfm12-1.1/src/rfm12.c **** 		rfm12_data(RFM12_CMD_TX | PREAMBLE);
 714               	.LM98:
 715 022a 8AEA      		ldi r24,lo8(-86)
 716 022c 98EB      		ldi r25,lo8(-72)
 717 022e 00D0      		rcall rfm12_data
 448:../auxiliary/rfm12-1.1/src/rfm12.c **** 		rfm12_data(RFM12_CMD_TX | PREAMBLE);
 719               	.LM99:
 720 0230 8AEA      		ldi r24,lo8(-86)
 721 0232 98EB      		ldi r25,lo8(-72)
 722 0234 00D0      		rcall rfm12_data
 449:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 450:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//set ET in power register to enable transmission (hint: TX starts now)
 451:../auxiliary/rfm12-1.1/src/rfm12.c **** 		rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_DEFAULT | RFM12_PWRMGT_ET);
 724               	.LM100:
 725 0236 81E2      		ldi r24,lo8(33)
 726 0238 92E8      		ldi r25,lo8(-126)
 727 023a 00D0      		rcall rfm12_data
 452:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 453:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//enable the interrupt to continue the transmission
 454:../auxiliary/rfm12-1.1/src/rfm12.c **** 		RFM12_INT_ON();
 729               	.LM101:
 730 023c E99A      		sbi 0x1d,1
 731 023e 0895      		ret
 733               	.Lscope9:
 735               		.stabd	78,0,0
 739               	.global	rfm12_start_tx
 741               	rfm12_start_tx:
 742               		.stabd	46,0,0
 455:../auxiliary/rfm12-1.1/src/rfm12.c **** 	}
 456:../auxiliary/rfm12-1.1/src/rfm12.c **** }
 457:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 458:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 459:../auxiliary/rfm12-1.1/src/rfm12.c **** //! Enqueue an already buffered packet for transmission
 460:../auxiliary/rfm12-1.1/src/rfm12.c **** /** If there is no active transmission, the packet header is written to the
 461:../auxiliary/rfm12-1.1/src/rfm12.c **** * transmission control buffer and the packet will be enqueued for transmission. \n
 462:../auxiliary/rfm12-1.1/src/rfm12.c **** * This function is not responsible for buffering the actual packet data.
 463:../auxiliary/rfm12-1.1/src/rfm12.c **** * The data has to be copied into the transmit buffer beforehand,
 464:../auxiliary/rfm12-1.1/src/rfm12.c **** * which can be accomplished by the rfm12_tx() function.
 465:../auxiliary/rfm12-1.1/src/rfm12.c **** *
 466:../auxiliary/rfm12-1.1/src/rfm12.c **** * \note Note that this function does not start the transmission, it merely enqueues the packet. \n
 467:../auxiliary/rfm12-1.1/src/rfm12.c **** * Transmissions are started by rfm12_tick().
 468:../auxiliary/rfm12-1.1/src/rfm12.c **** * \param [type] The packet header type field
 469:../auxiliary/rfm12-1.1/src/rfm12.c **** * \param [length] The packet data length
 470:../auxiliary/rfm12-1.1/src/rfm12.c **** * \returns One of these defines: \ref tx_retvals "TX return values"
 471:../auxiliary/rfm12-1.1/src/rfm12.c **** * \see rfm12_tx() and rfm12_tick()
 472:../auxiliary/rfm12-1.1/src/rfm12.c **** */
 473:../auxiliary/rfm12-1.1/src/rfm12.c **** #if (RFM12_NORETURNS)
 474:../auxiliary/rfm12-1.1/src/rfm12.c **** void 
 475:../auxiliary/rfm12-1.1/src/rfm12.c **** #else
 476:../auxiliary/rfm12-1.1/src/rfm12.c **** uint8_t
 477:../auxiliary/rfm12-1.1/src/rfm12.c **** #endif
 478:../auxiliary/rfm12-1.1/src/rfm12.c **** rfm12_start_tx(uint8_t type, uint8_t length)
 479:../auxiliary/rfm12-1.1/src/rfm12.c **** {
 744               	.LM102:
 745               	.LFBB10:
 746               	/* prologue: function */
 747               	/* frame size = 0 */
 748               	/* stack size = 0 */
 749               	.L__stack_usage = 0
 480:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//exit if the buffer isn't free
 481:../auxiliary/rfm12-1.1/src/rfm12.c **** 	if(ctrl.txstate != STATUS_FREE)
 751               	.LM103:
 752 0240 9091 0000 		lds r25,ctrl+1
 753 0244 9111      		cpse r25,__zero_reg__
 754 0246 00C0      		rjmp .L44
 482:../auxiliary/rfm12-1.1/src/rfm12.c **** 		return TXRETURN(RFM12_TX_OCCUPIED);
 483:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 484:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//write airlab header to buffer
 485:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rf_tx_buffer.len = length;
 756               	.LM104:
 757 0248 6093 0000 		sts rf_tx_buffer+2,r22
 486:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rf_tx_buffer.type = type;
 759               	.LM105:
 760 024c 8093 0000 		sts rf_tx_buffer+3,r24
 487:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rf_tx_buffer.checksum = length ^ type ^ 0xff;
 762               	.LM106:
 763 0250 8627      		eor r24,r22
 764 0252 8095      		com r24
 765 0254 8093 0000 		sts rf_tx_buffer+4,r24
 488:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 489:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//schedule packet for transmission
 490:../auxiliary/rfm12-1.1/src/rfm12.c **** 	ctrl.txstate = STATUS_OCCUPIED;
 767               	.LM107:
 768 0258 81E0      		ldi r24,lo8(1)
 769 025a 8093 0000 		sts ctrl+1,r24
 491:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 492:../auxiliary/rfm12-1.1/src/rfm12.c **** 	return TXRETURN(RFM12_TX_ENQUEUED);
 771               	.LM108:
 772 025e 80E8      		ldi r24,lo8(-128)
 773 0260 0895      		ret
 774               	.L44:
 482:../auxiliary/rfm12-1.1/src/rfm12.c **** 		return TXRETURN(RFM12_TX_OCCUPIED);
 776               	.LM109:
 777 0262 83E0      		ldi r24,lo8(3)
 493:../auxiliary/rfm12-1.1/src/rfm12.c **** }
 779               	.LM110:
 780 0264 0895      		ret
 782               	.Lscope10:
 784               		.stabd	78,0,0
 789               	.global	rfm12_tx
 791               	rfm12_tx:
 792               		.stabd	46,0,0
 494:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 495:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 496:../auxiliary/rfm12-1.1/src/rfm12.c **** //! Copy a packet to the buffer and call rfm12_start_tx() to enqueue it for transmission.
 497:../auxiliary/rfm12-1.1/src/rfm12.c **** /** If there is no active transmission, the buffer contents will be copied to the
 498:../auxiliary/rfm12-1.1/src/rfm12.c **** * internal transmission buffer. Finally the buffered packet is going to be enqueued by
 499:../auxiliary/rfm12-1.1/src/rfm12.c **** * calling rfm12_start_tx(). If automatic buffering of packet data is not necessary,
 500:../auxiliary/rfm12-1.1/src/rfm12.c **** * which is the case when the packet data does not change while the packet is enqueued
 501:../auxiliary/rfm12-1.1/src/rfm12.c **** * for transmission, then one could directly store the data in \ref rf_tx_buffer
 502:../auxiliary/rfm12-1.1/src/rfm12.c **** * (see rf_tx_buffer_t) and use the rfm12_start_tx() function.
 503:../auxiliary/rfm12-1.1/src/rfm12.c **** * 
 504:../auxiliary/rfm12-1.1/src/rfm12.c **** * \note Note that this function does not start the transmission, it merely enqueues the packet. \n
 505:../auxiliary/rfm12-1.1/src/rfm12.c **** * Transmissions are started by rfm12_tick().
 506:../auxiliary/rfm12-1.1/src/rfm12.c **** * \param [len] The packet data length
 507:../auxiliary/rfm12-1.1/src/rfm12.c **** * \param [type] The packet header type field
 508:../auxiliary/rfm12-1.1/src/rfm12.c **** * \param [data] Pointer to the packet data
 509:../auxiliary/rfm12-1.1/src/rfm12.c **** * \returns One of these defines: \ref tx_retvals "TX return values"
 510:../auxiliary/rfm12-1.1/src/rfm12.c **** * \see rfm12_start_tx() and rfm12_tick()
 511:../auxiliary/rfm12-1.1/src/rfm12.c **** */
 512:../auxiliary/rfm12-1.1/src/rfm12.c **** #if (RFM12_NORETURNS)
 513:../auxiliary/rfm12-1.1/src/rfm12.c **** void
 514:../auxiliary/rfm12-1.1/src/rfm12.c **** #else
 515:../auxiliary/rfm12-1.1/src/rfm12.c **** uint8_t 
 516:../auxiliary/rfm12-1.1/src/rfm12.c **** #endif
 517:../auxiliary/rfm12-1.1/src/rfm12.c **** rfm12_tx(uint8_t len, uint8_t type, uint8_t *data)
 518:../auxiliary/rfm12-1.1/src/rfm12.c **** {
 794               	.LM111:
 795               	.LFBB11:
 796 0266 CF93      		push r28
 797 0268 DF93      		push r29
 798               	/* prologue: function */
 799               	/* frame size = 0 */
 800               	/* stack size = 2 */
 801               	.L__stack_usage = 2
 802 026a C82F      		mov r28,r24
 803 026c D62F      		mov r29,r22
 804 026e BA01      		movw r22,r20
 519:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if RFM12_UART_DEBUG
 520:../auxiliary/rfm12-1.1/src/rfm12.c **** 		uart_putstr ("sending packet\r\n");
 521:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif
 522:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 523:../auxiliary/rfm12-1.1/src/rfm12.c **** 	if (len > RFM12_TX_BUFFER_SIZE) return TXRETURN(RFM12_TX_ERROR);
 806               	.LM112:
 807 0270 8F31      		cpi r24,lo8(31)
 808 0272 00F0      		brlo .L50
 809 0274 82E0      		ldi r24,lo8(2)
 810               	.L46:
 811               	/* epilogue start */
 524:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 525:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//exit if the buffer isn't free
 526:../auxiliary/rfm12-1.1/src/rfm12.c **** 	if(ctrl.txstate != STATUS_FREE)
 527:../auxiliary/rfm12-1.1/src/rfm12.c **** 		return TXRETURN(RFM12_TX_OCCUPIED);
 528:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 529:../auxiliary/rfm12-1.1/src/rfm12.c **** 	memcpy ( rf_tx_buffer.buffer, data, len );
 530:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 531:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if (!(RFM12_NORETURNS))
 532:../auxiliary/rfm12-1.1/src/rfm12.c **** 	return rfm12_start_tx (type, len);
 533:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#else
 534:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_start_tx (type, len);
 535:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif
 536:../auxiliary/rfm12-1.1/src/rfm12.c **** }
 813               	.LM113:
 814 0276 DF91      		pop r29
 815 0278 CF91      		pop r28
 816 027a 0895      		ret
 817               	.L50:
 526:../auxiliary/rfm12-1.1/src/rfm12.c **** 	if(ctrl.txstate != STATUS_FREE)
 819               	.LM114:
 820 027c 8091 0000 		lds r24,ctrl+1
 821 0280 8823      		tst r24
 822 0282 01F0      		breq .L47
 823               	.L48:
 527:../auxiliary/rfm12-1.1/src/rfm12.c **** 		return TXRETURN(RFM12_TX_OCCUPIED);
 825               	.LM115:
 826 0284 83E0      		ldi r24,lo8(3)
 827               	/* epilogue start */
 829               	.LM116:
 830 0286 DF91      		pop r29
 831 0288 CF91      		pop r28
 832 028a 0895      		ret
 833               	.L47:
 529:../auxiliary/rfm12-1.1/src/rfm12.c **** 	memcpy ( rf_tx_buffer.buffer, data, len );
 835               	.LM117:
 836 028c 4C2F      		mov r20,r28
 837 028e 50E0      		ldi r21,0
 838 0290 80E0      		ldi r24,lo8(rf_tx_buffer+5)
 839 0292 90E0      		ldi r25,hi8(rf_tx_buffer+5)
 840 0294 00D0      		rcall memcpy
 841               	.LBB23:
 842               	.LBB24:
 481:../auxiliary/rfm12-1.1/src/rfm12.c **** 	if(ctrl.txstate != STATUS_FREE)
 844               	.LM118:
 845 0296 8091 0000 		lds r24,ctrl+1
 846 029a 8111      		cpse r24,__zero_reg__
 847 029c 00C0      		rjmp .L48
 485:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rf_tx_buffer.len = length;
 849               	.LM119:
 850 029e C093 0000 		sts rf_tx_buffer+2,r28
 486:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rf_tx_buffer.type = type;
 852               	.LM120:
 853 02a2 D093 0000 		sts rf_tx_buffer+3,r29
 487:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rf_tx_buffer.checksum = length ^ type ^ 0xff;
 855               	.LM121:
 856 02a6 CD27      		eor r28,r29
 857 02a8 C095      		com r28
 858 02aa C093 0000 		sts rf_tx_buffer+4,r28
 490:../auxiliary/rfm12-1.1/src/rfm12.c **** 	ctrl.txstate = STATUS_OCCUPIED;
 860               	.LM122:
 861 02ae 81E0      		ldi r24,lo8(1)
 862 02b0 8093 0000 		sts ctrl+1,r24
 492:../auxiliary/rfm12-1.1/src/rfm12.c **** 	return TXRETURN(RFM12_TX_ENQUEUED);
 864               	.LM123:
 865 02b4 80E8      		ldi r24,lo8(-128)
 866 02b6 00C0      		rjmp .L46
 867               	.LBE24:
 868               	.LBE23:
 870               	.Lscope11:
 872               		.stabd	78,0,0
 874               	.global	rfm12_rx_clear
 876               	rfm12_rx_clear:
 877               		.stabd	46,0,0
 537:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 538:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 539:../auxiliary/rfm12-1.1/src/rfm12.c **** //if receive mode is not disabled (default)
 540:../auxiliary/rfm12-1.1/src/rfm12.c **** #if !(RFM12_TRANSMIT_ONLY)
 541:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//! Function to clear buffer complete/occupied status.
 542:../auxiliary/rfm12-1.1/src/rfm12.c **** 	/** This function will set the current receive buffer status to free and switch
 543:../auxiliary/rfm12-1.1/src/rfm12.c **** 	* to the other buffer, which can then be read using rfm12_rx_buffer().
 544:../auxiliary/rfm12-1.1/src/rfm12.c **** 	*
 545:../auxiliary/rfm12-1.1/src/rfm12.c **** 	* \see rfm12_rx_status(), rfm12_rx_len(), rfm12_rx_type(), rfm12_rx_buffer() and rf_rx_buffers
 546:../auxiliary/rfm12-1.1/src/rfm12.c **** 	*/
 547:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//warning: without the attribute, gcc will inline this even if -Os is set
 548:../auxiliary/rfm12-1.1/src/rfm12.c **** 	void __attribute__((noinline)) rfm12_rx_clear(void)
 549:../auxiliary/rfm12-1.1/src/rfm12.c **** 	{
 879               	.LM124:
 880               	.LFBB12:
 881               	/* prologue: function */
 882               	/* frame size = 0 */
 883               	/* stack size = 0 */
 884               	.L__stack_usage = 0
 550:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//mark the current buffer as empty
 551:../auxiliary/rfm12-1.1/src/rfm12.c **** 			ctrl.rf_buffer_out->status = STATUS_FREE;
 886               	.LM125:
 887 02b8 E0E0      		ldi r30,lo8(ctrl+6)
 888 02ba F0E0      		ldi r31,hi8(ctrl+6)
 889 02bc A081      		ld r26,Z
 890 02be B181      		ldd r27,Z+1
 891 02c0 1C92      		st X,__zero_reg__
 552:../auxiliary/rfm12-1.1/src/rfm12.c **** 			
 553:../auxiliary/rfm12-1.1/src/rfm12.c **** 			//switch to the other buffer
 554:../auxiliary/rfm12-1.1/src/rfm12.c **** 			ctrl.buffer_out_num = (ctrl.buffer_out_num + 1 ) % 2 ;
 893               	.LM126:
 894 02c2 A0E0      		ldi r26,lo8(ctrl+9)
 895 02c4 B0E0      		ldi r27,hi8(ctrl+9)
 896 02c6 8C91      		ld r24,X
 897 02c8 90E0      		ldi r25,0
 898 02ca 0196      		adiw r24,1
 899 02cc 8170      		andi r24,1
 900 02ce 9927      		clr r25
 901 02d0 8C93      		st X,r24
 555:../auxiliary/rfm12-1.1/src/rfm12.c **** 			ctrl.rf_buffer_out = &rf_rx_buffers[ctrl.buffer_out_num];
 903               	.LM127:
 904 02d2 42E2      		ldi r20,lo8(34)
 905 02d4 489F      		mul r20,r24
 906 02d6 9001      		movw r18,r0
 907 02d8 499F      		mul r20,r25
 908 02da 300D      		add r19,r0
 909 02dc 1124      		clr __zero_reg__
 910 02de 2050      		subi r18,lo8(-(rf_rx_buffers))
 911 02e0 3040      		sbci r19,hi8(-(rf_rx_buffers))
 912 02e2 3183      		std Z+1,r19
 913 02e4 2083      		st Z,r18
 914 02e6 0895      		ret
 916               	.Lscope12:
 918               		.stabd	78,0,0
 920               	.global	rfm12_init
 922               	rfm12_init:
 923               		.stabd	46,0,0
 556:../auxiliary/rfm12-1.1/src/rfm12.c **** 		
 557:../auxiliary/rfm12-1.1/src/rfm12.c **** 	}
 558:../auxiliary/rfm12-1.1/src/rfm12.c **** #endif /* !(RFM12_TRANSMIT_ONLY) */
 559:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 560:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 561:../auxiliary/rfm12-1.1/src/rfm12.c **** //! This is the main library initialization function
 562:../auxiliary/rfm12-1.1/src/rfm12.c **** /**This function takes care of all module initialization, including:
 563:../auxiliary/rfm12-1.1/src/rfm12.c **** * - Setup of the used frequency band and external capacitor
 564:../auxiliary/rfm12-1.1/src/rfm12.c **** * - Setting the exact frequency (channel)
 565:../auxiliary/rfm12-1.1/src/rfm12.c **** * - Setting the transmission data rate
 566:../auxiliary/rfm12-1.1/src/rfm12.c **** * - Configuring various module related rx parameters, including the amplification
 567:../auxiliary/rfm12-1.1/src/rfm12.c **** * - Enabling the digital data filter
 568:../auxiliary/rfm12-1.1/src/rfm12.c **** * - Enabling the use of the modules fifo, as well as enabling sync pattern detection
 569:../auxiliary/rfm12-1.1/src/rfm12.c **** * - Configuring the automatic frequency correction
 570:../auxiliary/rfm12-1.1/src/rfm12.c **** * - Setting the transmit power 
 571:../auxiliary/rfm12-1.1/src/rfm12.c **** *
 572:../auxiliary/rfm12-1.1/src/rfm12.c **** * This initialization function also sets up various library internal configuration structs and
 573:../auxiliary/rfm12-1.1/src/rfm12.c **** * puts the module into receive mode before returning.
 574:../auxiliary/rfm12-1.1/src/rfm12.c **** *
 575:../auxiliary/rfm12-1.1/src/rfm12.c **** * \note Please note that the transmit power and receive amplification values are currently hard cod
 576:../auxiliary/rfm12-1.1/src/rfm12.c **** * Have a look into rfm12_hw.h for possible settings.
 577:../auxiliary/rfm12-1.1/src/rfm12.c **** */
 578:../auxiliary/rfm12-1.1/src/rfm12.c **** void rfm12_init(void)
 579:../auxiliary/rfm12-1.1/src/rfm12.c **** {
 925               	.LM128:
 926               	.LFBB13:
 927               	/* prologue: function */
 928               	/* frame size = 0 */
 929               	/* stack size = 0 */
 930               	.L__stack_usage = 0
 580:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//initialize spi
 581:../auxiliary/rfm12-1.1/src/rfm12.c **** 	SS_RELEASE();
 932               	.LM129:
 933 02e8 5C9A      		sbi 0xb,4
 582:../auxiliary/rfm12-1.1/src/rfm12.c **** 	DDR_SS |= (1<<BIT_SS);	
 935               	.LM130:
 936 02ea 549A      		sbi 0xa,4
 937               	.LBB25:
 938               	.LBB26:
 940               	.Ltext3:
 179:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	DDR_MOSI   |= (_BV(BIT_MOSI));
 942               	.LM131:
 943 02ec 579A      		sbi 0xa,7
 180:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	DDR_SCK    |= (_BV(BIT_SCK));
 945               	.LM132:
 946 02ee 559A      		sbi 0xa,5
 181:../auxiliary/rfm12-1.1/src/include/rfm12_spi.c **** 	DDR_SPI_SS |= (_BV(BIT_SPI_SS));
 948               	.LM133:
 949 02f0 549A      		sbi 0xa,4
 951               	.LM134:
 952 02f2 5698      		cbi 0xa,6
 953               	.LBE26:
 954               	.LBE25:
 956               	.Ltext4:
 583:../auxiliary/rfm12-1.1/src/rfm12.c **** 	spi_init();
 584:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 585:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//enable internal data register and fifo
 586:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//setup selected band
 587:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(RFM12_CMD_CFG | RFM12_CFG_EL | RFM12_CFG_EF | RFM12_BASEBAND | RFM12_XTAL_12PF);
 958               	.LM135:
 959 02f4 87ED      		ldi r24,lo8(-41)
 960 02f6 90E8      		ldi r25,lo8(-128)
 961 02f8 00D0      		rcall rfm12_data
 588:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 589:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//set power default state (usually disable clock output)
 590:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//do not write the power register two times in a short time
 591:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//as it seems to need some recovery
 592:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_DEFAULT);
 963               	.LM136:
 964 02fa 81E0      		ldi r24,lo8(1)
 965 02fc 92E8      		ldi r25,lo8(-126)
 966 02fe 00D0      		rcall rfm12_data
 593:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 594:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//set frequency
 595:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(RFM12_CMD_FREQUENCY | RFM12_FREQUENCY_CALC(FREQ) );
 968               	.LM137:
 969 0300 86EF      		ldi r24,lo8(-10)
 970 0302 94EA      		ldi r25,lo8(-92)
 971 0304 00D0      		rcall rfm12_data
 596:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 597:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//set data rate
 598:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(RFM12_CMD_DATARATE | DATARATE_VALUE );
 973               	.LM138:
 974 0306 83E2      		ldi r24,lo8(35)
 975 0308 96EC      		ldi r25,lo8(-58)
 976 030a 00D0      		rcall rfm12_data
 599:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 600:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//set rx parameters: int-in/vdi-out pin is vdi-out,
 601:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//Bandwith, LNA, RSSI
 602:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(RFM12_CMD_RXCTRL | RFM12_RXCTRL_P16_VDI 
 978               	.LM139:
 979 030c 8CE2      		ldi r24,lo8(44)
 980 030e 94E9      		ldi r25,lo8(-108)
 981 0310 00D0      		rcall rfm12_data
 603:../auxiliary/rfm12-1.1/src/rfm12.c **** 			| RFM12_RXCTRL_VDI_FAST | RFM12_RXCTRL_BW_400 | RFM12_RXCTRL_LNA_6 
 604:../auxiliary/rfm12-1.1/src/rfm12.c **** 			| RFM12_RXCTRL_RSSI_79 );	
 605:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 606:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//automatic clock lock control(AL), digital Filter(!S),
 607:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//Data quality detector value 3, slow clock recovery lock
 608:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(RFM12_CMD_DATAFILTER | RFM12_DATAFILTER_AL | 3);
 983               	.LM140:
 984 0312 8BEA      		ldi r24,lo8(-85)
 985 0314 92EC      		ldi r25,lo8(-62)
 986 0316 00D0      		rcall rfm12_data
 609:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 610:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//2 Byte Sync Pattern, Start fifo fill when sychron pattern received,
 611:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//disable sensitive reset, Fifo filled interrupt at 8 bits
 612:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(RFM12_CMD_FIFORESET | RFM12_FIFORESET_DR | (8<<4));
 988               	.LM141:
 989 0318 81E8      		ldi r24,lo8(-127)
 990 031a 9AEC      		ldi r25,lo8(-54)
 991 031c 00D0      		rcall rfm12_data
 613:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 614:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//set AFC to automatic, (+4 or -3)*2.5kHz Limit, fine mode, active and enabled
 615:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(RFM12_CMD_AFC | RFM12_AFC_AUTO_KEEP | RFM12_AFC_LIMIT_4
 993               	.LM142:
 994 031e 87EF      		ldi r24,lo8(-9)
 995 0320 94EC      		ldi r25,lo8(-60)
 996 0322 00D0      		rcall rfm12_data
 616:../auxiliary/rfm12-1.1/src/rfm12.c **** 				| RFM12_AFC_FI | RFM12_AFC_OE | RFM12_AFC_EN);
 617:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 618:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//set TX Power to -0dB, frequency shift = +-125kHz
 619:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(RFM12_CMD_TXCONF | RFM12_TXCONF_POWER_0 | RFM12_TXCONF_FS_CALC(125000) );
 998               	.LM143:
 999 0324 80E7      		ldi r24,lo8(112)
 1000 0326 98E9      		ldi r25,lo8(-104)
 1001 0328 00D0      		rcall rfm12_data
 620:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 621:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//disable low dutycycle mode
 622:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(RFM12_CMD_DUTYCYCLE);
 1003               	.LM144:
 1004 032a 80E0      		ldi r24,0
 1005 032c 98EC      		ldi r25,lo8(-56)
 1006 032e 00D0      		rcall rfm12_data
 623:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 624:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//disable wakeup timer
 625:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(RFM12_CMD_WAKEUP);
 1008               	.LM145:
 1009 0330 80E0      		ldi r24,0
 1010 0332 90EE      		ldi r25,lo8(-32)
 1011 0334 00D0      		rcall rfm12_data
 626:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 627:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//store the syncronization pattern to the transmission buffer
 628:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//the sync pattern is used by the receiver to distinguish noise from real transmissions
 629:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//the sync pattern is hardcoded into the receiver
 630:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rf_tx_buffer.sync[0] = SYNC_MSB;
 1013               	.LM146:
 1014 0336 8DE2      		ldi r24,lo8(45)
 1015 0338 8093 0000 		sts rf_tx_buffer,r24
 631:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rf_tx_buffer.sync[1] = SYNC_LSB;
 1017               	.LM147:
 1018 033c 84ED      		ldi r24,lo8(-44)
 1019 033e 8093 0000 		sts rf_tx_buffer+1,r24
 632:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 633:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//if receive mode is not disabled (default)
 634:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if !(RFM12_TRANSMIT_ONLY)
 635:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//init buffer pointers
 636:../auxiliary/rfm12-1.1/src/rfm12.c **** 		ctrl.rf_buffer_out = &rf_rx_buffers[0];
 1021               	.LM148:
 1022 0342 80E0      		ldi r24,lo8(rf_rx_buffers)
 1023 0344 90E0      		ldi r25,hi8(rf_rx_buffers)
 1024 0346 9093 0000 		sts ctrl+6+1,r25
 1025 034a 8093 0000 		sts ctrl+6,r24
 637:../auxiliary/rfm12-1.1/src/rfm12.c **** 		ctrl.rf_buffer_in  = &rf_rx_buffers[0];
 1027               	.LM149:
 1028 034e 9093 0000 		sts ctrl+4+1,r25
 1029 0352 8093 0000 		sts ctrl+4,r24
 638:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//ctrl.buffer_in_num = 0;
 639:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//ctrl.buffer_out_num = 0;
 640:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif /* !(RFM12_TRANSMIT_ONLY) */
 641:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 642:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//low battery detector feature initialization
 643:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if RFM12_LOW_BATT_DETECTOR
 644:../auxiliary/rfm12-1.1/src/rfm12.c **** 		ctrl.low_batt = RFM12_BATT_OKAY;
 645:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif /* RFM12_LOW_BATT_DETECTOR */
 646:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 647:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//enable rf receiver chain, if receiving is not disabled (default)
 648:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//the magic is done via defines
 649:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_RECEIVE);
 1031               	.LM150:
 1032 0356 81E8      		ldi r24,lo8(-127)
 1033 0358 92E8      		ldi r25,lo8(-126)
 1034 035a 00D0      		rcall rfm12_data
 650:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 651:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//wakeup timer feature setup
 652:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if RFM12_USE_WAKEUP_TIMER
 653:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//set power management shadow register to receiver chain enabled or disabled
 654:../auxiliary/rfm12-1.1/src/rfm12.c **** 		//the define correctly handles the transmit only mode
 655:../auxiliary/rfm12-1.1/src/rfm12.c **** 		ctrl.pwrmgt_shadow = (RFM12_CMD_PWRMGT | PWRMGT_RECEIVE);
 656:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif /* RFM12_USE_WAKEUP_TIMER */
 657:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 658:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//ASK receive mode feature initialization
 659:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#if RFM12_RECEIVE_ASK
 660:../auxiliary/rfm12-1.1/src/rfm12.c **** 		adc_init();
 661:../auxiliary/rfm12-1.1/src/rfm12.c **** 	#endif
 662:../auxiliary/rfm12-1.1/src/rfm12.c **** 
 663:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//setup interrupt for falling edge trigger
 664:../auxiliary/rfm12-1.1/src/rfm12.c **** 	RFM12_INT_SETUP();
 1036               	.LM151:
 1037 035c E9E6      		ldi r30,lo8(105)
 1038 035e F0E0      		ldi r31,0
 1039 0360 8081      		ld r24,Z
 1040 0362 8860      		ori r24,lo8(8)
 1041 0364 8083      		st Z,r24
 665:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 666:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//clear int flag
 667:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_read(RFM12_CMD_STATUS);
 1043               	.LM152:
 1044 0366 80E0      		ldi r24,0
 1045 0368 90E0      		ldi r25,0
 1046 036a 00D0      		rcall rfm12_read
 668:../auxiliary/rfm12-1.1/src/rfm12.c **** 	RFM12_INT_FLAG |= (1<<RFM12_FLAG_BIT);		
 1048               	.LM153:
 1049 036c E19A      		sbi 0x1c,1
 669:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 670:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//init receiver fifo, we now begin receiving.
 671:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(CLEAR_FIFO);
 1051               	.LM154:
 1052 036e 81E8      		ldi r24,lo8(-127)
 1053 0370 9AEC      		ldi r25,lo8(-54)
 1054 0372 00D0      		rcall rfm12_data
 672:../auxiliary/rfm12-1.1/src/rfm12.c **** 	rfm12_data(ACCEPT_DATA);
 1056               	.LM155:
 1057 0374 83E8      		ldi r24,lo8(-125)
 1058 0376 9AEC      		ldi r25,lo8(-54)
 1059 0378 00D0      		rcall rfm12_data
 673:../auxiliary/rfm12-1.1/src/rfm12.c **** 	
 674:../auxiliary/rfm12-1.1/src/rfm12.c **** 	//activate the interrupt
 675:../auxiliary/rfm12-1.1/src/rfm12.c **** 	RFM12_INT_ON();	
 1061               	.LM156:
 1062 037a E99A      		sbi 0x1d,1
 1063 037c 0895      		ret
 1065               	.Lscope13:
 1067               		.stabd	78,0,0
 1068               		.section	.rodata.str1.1,"aMS",@progbits,1
 1069               	.LC0:
 1070 0000 3434 3434 		.string	"444444"
 1070      3434 00
 1071               		.section	.text.startup,"ax",@progbits
 1073               	.global	main
 1075               	main:
 1076               		.stabd	46,0,0
 1078               	.Ltext5:
   1:serial-link-transceiver.c **** /**
   2:serial-link-transceiver.c **** @mainpage Power Control Project Serial Link Transceiver
   3:serial-link-transceiver.c **** @version 0.0.0
   4:serial-link-transceiver.c **** @author Ken Sarkies (www.jiggerjuice.net)
   5:serial-link-transceiver.c **** @date 09 October 2014
   6:serial-link-transceiver.c **** @brief Code for a Serial Link Transceiver based on RFM12B
   7:serial-link-transceiver.c **** 
   8:serial-link-transceiver.c **** This is a project to provide an RF link for serial communications between
   9:serial-link-transceiver.c **** a PC and a remote unit. The hardware used is part of the Remote Power Control
  10:serial-link-transceiver.c **** project that has been adapted to use a Hope RFM12B 433MHz transceiver module
  11:serial-link-transceiver.c **** rather than the RFM01 receiver module.
  12:serial-link-transceiver.c **** 
  13:serial-link-transceiver.c **** The firmware draws on the rfm12lib AVR library provided by Hansinator, Tixiv
  14:serial-link-transceiver.c **** and Soeren at:
  15:serial-link-transceiver.c **** https://www.das-labor.org/wiki/RFM12_library/en
  16:serial-link-transceiver.c **** 
  17:serial-link-transceiver.c **** @note
  18:serial-link-transceiver.c **** Software: AVR-GCC 4.8.2
  19:serial-link-transceiver.c **** @note
  20:serial-link-transceiver.c **** Target:   Any AVR with sufficient output ports and a timer
  21:serial-link-transceiver.c **** @note
  22:serial-link-transceiver.c **** Tested:   ATMega48 at 8MHz internal clock.
  23:serial-link-transceiver.c ****  */
  24:serial-link-transceiver.c **** /***************************************************************************
  25:serial-link-transceiver.c ****  *   Copyright (C) 2014 by Ken Sarkies                                     *
  26:serial-link-transceiver.c ****  *   ksarkies@internode.on.net                                             *
  27:serial-link-transceiver.c ****  *                                                                         *
  28:serial-link-transceiver.c ****  *   This file is part of Power Controller                                 *
  29:serial-link-transceiver.c ****  *                                                                         *
  30:serial-link-transceiver.c ****  *   This is free software; you can redistribute it and/or modify          *
  31:serial-link-transceiver.c ****  *   it under the terms of the GNU General Public License as published by  *
  32:serial-link-transceiver.c ****  *   the Free Software Foundation; either version 2 of the License, or     *
  33:serial-link-transceiver.c ****  *   (at your option) any later version.                                   *
  34:serial-link-transceiver.c ****  *                                                                         *
  35:serial-link-transceiver.c ****  *   This software is distributed in the hope that it will be useful,      *
  36:serial-link-transceiver.c ****  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  37:serial-link-transceiver.c ****  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
  38:serial-link-transceiver.c ****  *   GNU General Public License for more details.                          *
  39:serial-link-transceiver.c ****  *                                                                         *
  40:serial-link-transceiver.c ****  *   You should have received a copy of the GNU General Public License     *
  41:serial-link-transceiver.c ****  *   along with the software. If not, write to the:                        *
  42:serial-link-transceiver.c ****  *   Free Software Foundation, Inc.,                                       *
  43:serial-link-transceiver.c ****  *   51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA.             *
  44:serial-link-transceiver.c ****  ***************************************************************************/
  45:serial-link-transceiver.c **** 
  46:serial-link-transceiver.c **** #define F_CPU               8000000
  47:serial-link-transceiver.c **** 
  48:serial-link-transceiver.c **** #include <inttypes.h>
  49:serial-link-transceiver.c **** #include <avr/sfr_defs.h>
  50:serial-link-transceiver.c **** #include <avr/io.h>
  51:serial-link-transceiver.c **** #include <avr/wdt.h>
  52:serial-link-transceiver.c **** #include <avr/interrupt.h>
  53:serial-link-transceiver.c **** #include <avr/sleep.h>
  54:serial-link-transceiver.c **** #include <util/delay.h>
  55:serial-link-transceiver.c **** #include <string.h>
  56:serial-link-transceiver.c **** #include "../libs-master-receiver/defines-M48.h"
  57:serial-link-transceiver.c **** #include "../libs-master-receiver/power-control-atmega48.h"
  58:serial-link-transceiver.c **** #include "../libs-master-receiver/serial.h"
  59:serial-link-transceiver.c **** #include "../libs-master-receiver/timer.h"
  60:serial-link-transceiver.c **** #include "rfm12_config.h"
  61:serial-link-transceiver.c **** #include "../auxiliary/rfm12-1.1/src/rfm12.h"
  62:serial-link-transceiver.c **** #include "../auxiliary/rfm12-1.1/src/rfm12.c"
  63:serial-link-transceiver.c **** #include "serial-link-transceiver.h"
  64:serial-link-transceiver.c **** 
  65:serial-link-transceiver.c **** /** Convenience macros (we don't use them all) */
  66:serial-link-transceiver.c **** #define TRUE 1
  67:serial-link-transceiver.c **** #define FALSE 0
  68:serial-link-transceiver.c **** 
  69:serial-link-transceiver.c **** #define inb(sfr) _SFR_BYTE(sfr)
  70:serial-link-transceiver.c **** #define inw(sfr) _SFR_WORD(sfr)
  71:serial-link-transceiver.c **** #define outb(sfr, val) (_SFR_BYTE(sfr) = (val))
  72:serial-link-transceiver.c **** #define outw(sfr, val) (_SFR_WORD(sfr) = (val))
  73:serial-link-transceiver.c **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  74:serial-link-transceiver.c **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  75:serial-link-transceiver.c **** #define high(x) ((uint8_t) (x >> 8) & 0xFF)
  76:serial-link-transceiver.c **** #define low(x) ((uint8_t) (x & 0xFF))
  77:serial-link-transceiver.c **** 
  78:serial-link-transceiver.c **** /** SPI Clock Timing */
  79:serial-link-transceiver.c **** #define SPI_DELAY 1
  80:serial-link-transceiver.c **** 
  81:serial-link-transceiver.c **** /*****************************************************************************/
  82:serial-link-transceiver.c **** /* Global Variables */
  83:serial-link-transceiver.c **** 
  84:serial-link-transceiver.c **** /** @name UART variables */
  85:serial-link-transceiver.c **** /*@{*/
  86:serial-link-transceiver.c **** volatile uint16_t uartInput;    /**< Character and errorcode read from uart */
  87:serial-link-transceiver.c **** volatile uint8_t lastError;     /**< Error code for transmission back */
  88:serial-link-transceiver.c **** volatile uint8_t checkSum;      /**< Checksum on message contents */
  89:serial-link-transceiver.c **** /*@}*/
  90:serial-link-transceiver.c **** 
  91:serial-link-transceiver.c **** /** Real Time Clock Global Variable, ticks are 30.5 per second */
  92:serial-link-transceiver.c **** uint32_t timeValue;
  93:serial-link-transceiver.c **** /*****************************************************************************/
  94:serial-link-transceiver.c **** /* Local Prototypes */
  95:serial-link-transceiver.c **** 
  96:serial-link-transceiver.c **** void hardwareInit(void);
  97:serial-link-transceiver.c **** void timerInit(void);
  98:serial-link-transceiver.c **** void wdtInit(void);
  99:serial-link-transceiver.c **** /*****************************************************************************/
 100:serial-link-transceiver.c **** /** @brief Main Program */
 101:serial-link-transceiver.c **** 
 102:serial-link-transceiver.c **** int main(void)
 103:serial-link-transceiver.c **** {
 1080               	.LM157:
 1081               	.LFBB14:
 1082 0000 CF93      		push r28
 1083 0002 DF93      		push r29
 1084 0004 CDB7      		in r28,__SP_L__
 1085 0006 DEB7      		in r29,__SP_H__
 1086 0008 2797      		sbiw r28,7
 1087 000a 0FB6      		in __tmp_reg__,__SREG__
 1088 000c F894      		cli
 1089 000e DEBF      		out __SP_H__,r29
 1090 0010 0FBE      		out __SREG__,__tmp_reg__
 1091 0012 CDBF      		out __SP_L__,r28
 1092               	/* prologue: function */
 1093               	/* frame size = 7 */
 1094               	/* stack size = 9 */
 1095               	.L__stack_usage = 9
 104:serial-link-transceiver.c ****     hardwareInit();
 105:serial-link-transceiver.c ****     uartInit();
 1097               	.LM158:
 1098 0014 00D0      		rcall uartInit
 106:serial-link-transceiver.c ****     timer0Init(0,5);
 1100               	.LM159:
 1101 0016 65E0      		ldi r22,lo8(5)
 1102 0018 70E0      		ldi r23,0
 1103 001a 80E0      		ldi r24,0
 1104 001c 00D0      		rcall timer0Init
 1105               	.LBB27:
 1106               	.LBB28:
 1108               	.Ltext6:
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1110               	.LM160:
 1111 001e 2FE7      		ldi r18,lo8(399999)
 1112 0020 8AE1      		ldi r24,hi8(399999)
 1113 0022 96E0      		ldi r25,hlo8(399999)
 1114 0024 2150      		1: subi r18,1
 1115 0026 8040      		sbci r24,0
 1116 0028 9040      		sbci r25,0
 1117 002a 01F4      		brne 1b
 1118 002c 00C0      		rjmp .
 1119 002e 0000      		nop
 1120               	.LBE28:
 1121               	.LBE27:
 1122               	.LBB29:
 1123               	.LBB30:
 1124 0030 2FE7      		ldi r18,lo8(399999)
 1125 0032 8AE1      		ldi r24,hi8(399999)
 1126 0034 96E0      		ldi r25,hlo8(399999)
 1127 0036 2150      		1: subi r18,1
 1128 0038 8040      		sbci r24,0
 1129 003a 9040      		sbci r25,0
 1130 003c 01F4      		brne 1b
 1131 003e 00C0      		rjmp .
 1132 0040 0000      		nop
 1133               	.LBE30:
 1134               	.LBE29:
 1135               	.LBB31:
 1136               	.LBB32:
 1137 0042 2FE7      		ldi r18,lo8(399999)
 1138 0044 8AE1      		ldi r24,hi8(399999)
 1139 0046 96E0      		ldi r25,hlo8(399999)
 1140 0048 2150      		1: subi r18,1
 1141 004a 8040      		sbci r24,0
 1142 004c 9040      		sbci r25,0
 1143 004e 01F4      		brne 1b
 1144 0050 00C0      		rjmp .
 1145 0052 0000      		nop
 1146               	.LBE32:
 1147               	.LBE31:
 1149               	.Ltext7:
 107:serial-link-transceiver.c **** 	_delay_ms(250);
 108:serial-link-transceiver.c **** 	_delay_ms(250);
 109:serial-link-transceiver.c **** 	_delay_ms(250);
 110:serial-link-transceiver.c **** 
 111:serial-link-transceiver.c ****     rfm12_init();
 1151               	.LM161:
 1152 0054 00D0      		rcall rfm12_init
 112:serial-link-transceiver.c **** //    wdtInit();
 113:serial-link-transceiver.c ****     sei();
 1154               	.LM162:
 1155               	/* #APP */
 1156               	 ;  113 "serial-link-transceiver.c" 1
 1157 0056 7894      		sei
 1158               	 ;  0 "" 2
 1159               	/* #NOAPP */
 1160               	.LBB33:
 114:serial-link-transceiver.c **** 
 115:serial-link-transceiver.c ****     for(;;)
 116:serial-link-transceiver.c ****     {
 117:serial-link-transceiver.c **** //        wdt_reset();
 118:serial-link-transceiver.c **** 		if (rfm12_rx_status() == STATUS_COMPLETE)
 119:serial-link-transceiver.c **** 		{
 120:serial-link-transceiver.c **** 			uint8_t *bufcontents = rfm12_rx_buffer();
 121:serial-link-transceiver.c **** 
 122:serial-link-transceiver.c ****             sendch('A');
 123:serial-link-transceiver.c **** /* dump buffer contents to uart			 */
 124:serial-link-transceiver.c ****         	uint8_t i;
 125:serial-link-transceiver.c **** 			for (i=0;i<rfm12_rx_len();i++)
 126:serial-link-transceiver.c **** 			{
 127:serial-link-transceiver.c **** 				sendch(bufcontents[i]);
 128:serial-link-transceiver.c **** 			}
 129:serial-link-transceiver.c **** 			
 130:serial-link-transceiver.c **** /* Ttell the implementation that the buffer can be reused for the next data. */
 131:serial-link-transceiver.c **** 			rfm12_rx_clear();
 132:serial-link-transceiver.c **** 		}
 133:serial-link-transceiver.c **** /* Send a transmission every 30 ticks (about 1 second) */
 134:serial-link-transceiver.c **** 		if (timeValue > 30)
 135:serial-link-transceiver.c ****         {
 136:serial-link-transceiver.c ****             sendch('X');
 137:serial-link-transceiver.c ****         	uint8_t tv[] = "444444";
 1162               	.LM163:
 1163 0058 97E0      		ldi r25,lo8(7)
 1164 005a E92E      		mov r14,r25
 1165               	.LBE33:
 1166               	.LBB34:
 1167               	.LBB35:
 1169               	.Ltext8:
   1:../auxiliary/rfm12-1.1/src/rfm12.h **** /**** RFM 12 library for Atmel AVR Microcontrollers *******
   2:../auxiliary/rfm12-1.1/src/rfm12.h ****  *
   3:../auxiliary/rfm12-1.1/src/rfm12.h ****  * This software is free software; you can redistribute it and/or modify
   4:../auxiliary/rfm12-1.1/src/rfm12.h ****  * it under the terms of the GNU General Public License as published
   5:../auxiliary/rfm12-1.1/src/rfm12.h ****  * by the Free Software Foundation; either version 2 of the License,
   6:../auxiliary/rfm12-1.1/src/rfm12.h ****  * or (at your option) any later version.
   7:../auxiliary/rfm12-1.1/src/rfm12.h ****  *
   8:../auxiliary/rfm12-1.1/src/rfm12.h ****  * This software is distributed in the hope that it will be useful, but
   9:../auxiliary/rfm12-1.1/src/rfm12.h ****  * WITHOUT ANY WARRANTY; without even the implied warranty of
  10:../auxiliary/rfm12-1.1/src/rfm12.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  11:../auxiliary/rfm12-1.1/src/rfm12.h ****  * General Public License for more details.
  12:../auxiliary/rfm12-1.1/src/rfm12.h ****  *
  13:../auxiliary/rfm12-1.1/src/rfm12.h ****  * You should have received a copy of the GNU General Public License
  14:../auxiliary/rfm12-1.1/src/rfm12.h ****  * along with this software; if not, write to the Free Software
  15:../auxiliary/rfm12-1.1/src/rfm12.h ****  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
  16:../auxiliary/rfm12-1.1/src/rfm12.h ****  * USA.
  17:../auxiliary/rfm12-1.1/src/rfm12.h ****  *
  18:../auxiliary/rfm12-1.1/src/rfm12.h ****  * @author Peter Fuhrmann, Hans-Gert Dahmen, Soeren Heisrath
  19:../auxiliary/rfm12-1.1/src/rfm12.h ****  */
  20:../auxiliary/rfm12-1.1/src/rfm12.h ****  
  21:../auxiliary/rfm12-1.1/src/rfm12.h **** /** \file rfm12.h
  22:../auxiliary/rfm12-1.1/src/rfm12.h ****  * \brief rfm12 library main header
  23:../auxiliary/rfm12-1.1/src/rfm12.h ****  * \author Hans-Gert Dahmen
  24:../auxiliary/rfm12-1.1/src/rfm12.h ****  * \author Peter Fuhrmann
  25:../auxiliary/rfm12-1.1/src/rfm12.h ****  * \author Soeren Heisrath
  26:../auxiliary/rfm12-1.1/src/rfm12.h ****  * \version 0.9.0
  27:../auxiliary/rfm12-1.1/src/rfm12.h ****  * \date 08.09.09
  28:../auxiliary/rfm12-1.1/src/rfm12.h ****  *
  29:../auxiliary/rfm12-1.1/src/rfm12.h ****  * This header represents the library's core API.
  30:../auxiliary/rfm12-1.1/src/rfm12.h ****  */
  31:../auxiliary/rfm12-1.1/src/rfm12.h **** 
  32:../auxiliary/rfm12-1.1/src/rfm12.h **** /******************************************************
  33:../auxiliary/rfm12-1.1/src/rfm12.h ****  *                                                    *
  34:../auxiliary/rfm12-1.1/src/rfm12.h ****  *    NO  C O N F I G U R A T I O N  IN THIS FILE     *
  35:../auxiliary/rfm12-1.1/src/rfm12.h ****  *                                                    *
  36:../auxiliary/rfm12-1.1/src/rfm12.h ****  *      ( thou shalt not change lines below )         *
  37:../auxiliary/rfm12-1.1/src/rfm12.h ****  *                                                    *
  38:../auxiliary/rfm12-1.1/src/rfm12.h ****  ******************************************************/
  39:../auxiliary/rfm12-1.1/src/rfm12.h ****  
  40:../auxiliary/rfm12-1.1/src/rfm12.h **** #ifndef _RFM12_H
  41:../auxiliary/rfm12-1.1/src/rfm12.h **** #define _RFM12_H
  42:../auxiliary/rfm12-1.1/src/rfm12.h **** 
  43:../auxiliary/rfm12-1.1/src/rfm12.h **** /** \name States for rx and tx buffers
  44:../auxiliary/rfm12-1.1/src/rfm12.h **** * \anchor rxtx_states
  45:../auxiliary/rfm12-1.1/src/rfm12.h **** * \see rfm12_rx_status() and rfm12_control_t
  46:../auxiliary/rfm12-1.1/src/rfm12.h **** * @{
  47:../auxiliary/rfm12-1.1/src/rfm12.h **** */
  48:../auxiliary/rfm12-1.1/src/rfm12.h **** //! Indicates that the buffer is free
  49:../auxiliary/rfm12-1.1/src/rfm12.h **** #define STATUS_FREE 0
  50:../auxiliary/rfm12-1.1/src/rfm12.h **** //! Indicates that the buffer is in use by the library
  51:../auxiliary/rfm12-1.1/src/rfm12.h **** #define STATUS_OCCUPIED 1
  52:../auxiliary/rfm12-1.1/src/rfm12.h **** //! Indicates that a receive buffer holds a complete transmission
  53:../auxiliary/rfm12-1.1/src/rfm12.h **** #define STATUS_COMPLETE 2
  54:../auxiliary/rfm12-1.1/src/rfm12.h **** //@}
  55:../auxiliary/rfm12-1.1/src/rfm12.h **** 
  56:../auxiliary/rfm12-1.1/src/rfm12.h **** 
  57:../auxiliary/rfm12-1.1/src/rfm12.h **** /** \name  Return values for rfm12_tx() and rfm12_start_tx()
  58:../auxiliary/rfm12-1.1/src/rfm12.h **** * \anchor tx_retvals
  59:../auxiliary/rfm12-1.1/src/rfm12.h **** * \see rfm12_tx() and rfm12_start_tx()
  60:../auxiliary/rfm12-1.1/src/rfm12.h **** * @{
  61:../auxiliary/rfm12-1.1/src/rfm12.h **** */
  62:../auxiliary/rfm12-1.1/src/rfm12.h **** //!  The packet data is longer than the internal buffer
  63:../auxiliary/rfm12-1.1/src/rfm12.h **** #define RFM12_TX_ERROR 0x02
  64:../auxiliary/rfm12-1.1/src/rfm12.h **** //! The transmit buffer is already occupied
  65:../auxiliary/rfm12-1.1/src/rfm12.h **** #define RFM12_TX_OCCUPIED 0x03
  66:../auxiliary/rfm12-1.1/src/rfm12.h **** //! The packet has been enqueued successfully
  67:../auxiliary/rfm12-1.1/src/rfm12.h **** #define RFM12_TX_ENQUEUED 0x80
  68:../auxiliary/rfm12-1.1/src/rfm12.h **** //@}
  69:../auxiliary/rfm12-1.1/src/rfm12.h **** 
  70:../auxiliary/rfm12-1.1/src/rfm12.h **** 
  71:../auxiliary/rfm12-1.1/src/rfm12.h **** /************************
  72:../auxiliary/rfm12-1.1/src/rfm12.h ****  * function protoypes
  73:../auxiliary/rfm12-1.1/src/rfm12.h **** */
  74:../auxiliary/rfm12-1.1/src/rfm12.h **** 
  75:../auxiliary/rfm12-1.1/src/rfm12.h **** //see rfm12.c for more documentation
  76:../auxiliary/rfm12-1.1/src/rfm12.h **** void rfm12_init(void);
  77:../auxiliary/rfm12-1.1/src/rfm12.h **** void rfm12_tick(void);
  78:../auxiliary/rfm12-1.1/src/rfm12.h **** 
  79:../auxiliary/rfm12-1.1/src/rfm12.h **** //if receive mode is not disabled (default)
  80:../auxiliary/rfm12-1.1/src/rfm12.h **** #if !(RFM12_TRANSMIT_ONLY)
  81:../auxiliary/rfm12-1.1/src/rfm12.h **** 	void rfm12_rx_clear(void);
  82:../auxiliary/rfm12-1.1/src/rfm12.h **** #endif /* !(RFM12_TRANSMIT_ONLY) */
  83:../auxiliary/rfm12-1.1/src/rfm12.h **** 
  84:../auxiliary/rfm12-1.1/src/rfm12.h **** //FIXME: the tx function should return a status, do we need to do this also?
  85:../auxiliary/rfm12-1.1/src/rfm12.h **** // uint8_t rfm12_tx_status();
  86:../auxiliary/rfm12-1.1/src/rfm12.h **** 
  87:../auxiliary/rfm12-1.1/src/rfm12.h **** #if (RFM12_NORETURNS)
  88:../auxiliary/rfm12-1.1/src/rfm12.h **** //see rfm12.c for more documentation
  89:../auxiliary/rfm12-1.1/src/rfm12.h **** void rfm12_start_tx(uint8_t type, uint8_t length);
  90:../auxiliary/rfm12-1.1/src/rfm12.h **** void rfm12_tx(uint8_t len, uint8_t type, uint8_t *data);
  91:../auxiliary/rfm12-1.1/src/rfm12.h **** #else
  92:../auxiliary/rfm12-1.1/src/rfm12.h **** uint8_t rfm12_start_tx(uint8_t type, uint8_t length);
  93:../auxiliary/rfm12-1.1/src/rfm12.h **** uint8_t rfm12_tx(uint8_t len, uint8_t type, uint8_t *data);
  94:../auxiliary/rfm12-1.1/src/rfm12.h **** #endif
  95:../auxiliary/rfm12-1.1/src/rfm12.h **** 
  96:../auxiliary/rfm12-1.1/src/rfm12.h **** //if polling is used, define a polling function
  97:../auxiliary/rfm12-1.1/src/rfm12.h **** #if RFM12_USE_POLLING
  98:../auxiliary/rfm12-1.1/src/rfm12.h **** void rfm12_poll(void);
  99:../auxiliary/rfm12-1.1/src/rfm12.h **** #endif
 100:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 101:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 102:../auxiliary/rfm12-1.1/src/rfm12.h **** /************************
 103:../auxiliary/rfm12-1.1/src/rfm12.h ****  * private control structs
 104:../auxiliary/rfm12-1.1/src/rfm12.h ****  */
 105:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 106:../auxiliary/rfm12-1.1/src/rfm12.h **** //! The transmission buffer structure.
 107:../auxiliary/rfm12-1.1/src/rfm12.h **** /** \note Note that this complete buffer is transmitted sequentially,
 108:../auxiliary/rfm12-1.1/src/rfm12.h **** * beginning with the sync bytes.
 109:../auxiliary/rfm12-1.1/src/rfm12.h **** *
 110:../auxiliary/rfm12-1.1/src/rfm12.h **** * \see rfm12_start_tx(), rfm12_tx() and rf_tx_buffer
 111:../auxiliary/rfm12-1.1/src/rfm12.h **** */
 112:../auxiliary/rfm12-1.1/src/rfm12.h **** typedef struct
 113:../auxiliary/rfm12-1.1/src/rfm12.h **** {
 114:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//! Sync bytes for receiver to start filling fifo.
 115:../auxiliary/rfm12-1.1/src/rfm12.h **** 	uint8_t sync[2];
 116:../auxiliary/rfm12-1.1/src/rfm12.h **** 	
 117:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//! Length byte - number of bytes in buffer.
 118:../auxiliary/rfm12-1.1/src/rfm12.h **** 	uint8_t len;
 119:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 120:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//! Type field for the simple airlab protocol.
 121:../auxiliary/rfm12-1.1/src/rfm12.h **** 	uint8_t type;		
 122:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 123:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//! Checksum over the former two members.
 124:../auxiliary/rfm12-1.1/src/rfm12.h **** 	uint8_t checksum;
 125:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 126:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//! Buffer for the raw bytes to be transmitted.
 127:../auxiliary/rfm12-1.1/src/rfm12.h **** 	uint8_t buffer[RFM12_TX_BUFFER_SIZE];
 128:../auxiliary/rfm12-1.1/src/rfm12.h **** } rf_tx_buffer_t;
 129:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 130:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 131:../auxiliary/rfm12-1.1/src/rfm12.h **** //if receive mode is not disabled (default)
 132:../auxiliary/rfm12-1.1/src/rfm12.h **** #if !(RFM12_TRANSMIT_ONLY)
 133:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//! The receive buffer structure.
 134:../auxiliary/rfm12-1.1/src/rfm12.h **** 	/** \note Note that there will be two receive buffers of this type,
 135:../auxiliary/rfm12-1.1/src/rfm12.h **** 	* as double buffering is being employed by this library.
 136:../auxiliary/rfm12-1.1/src/rfm12.h **** 	*
 137:../auxiliary/rfm12-1.1/src/rfm12.h **** 	* \see rfm12_rx_status(), rfm12_rx_len(), rfm12_rx_type(), rfm12_rx_buffer() , rfm12_rx_clear() an
 138:../auxiliary/rfm12-1.1/src/rfm12.h **** 	*/
 139:../auxiliary/rfm12-1.1/src/rfm12.h **** 	typedef struct
 140:../auxiliary/rfm12-1.1/src/rfm12.h **** 	{
 141:../auxiliary/rfm12-1.1/src/rfm12.h **** 		//! Indicates if the buffer is free or completed.
 142:../auxiliary/rfm12-1.1/src/rfm12.h **** 		/** \see \ref rxtx_states "States for rx and tx buffers" */
 143:../auxiliary/rfm12-1.1/src/rfm12.h **** 		volatile uint8_t status;
 144:../auxiliary/rfm12-1.1/src/rfm12.h **** 		
 145:../auxiliary/rfm12-1.1/src/rfm12.h **** 		//! Length byte - number of bytes in buffer.
 146:../auxiliary/rfm12-1.1/src/rfm12.h **** 		uint8_t len;
 147:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 148:../auxiliary/rfm12-1.1/src/rfm12.h **** 		//! Type field for the simple airlab protocol.		
 149:../auxiliary/rfm12-1.1/src/rfm12.h **** 		uint8_t type;
 150:../auxiliary/rfm12-1.1/src/rfm12.h **** 		
 151:../auxiliary/rfm12-1.1/src/rfm12.h **** 		//! Checksum over the type and length header fields
 152:../auxiliary/rfm12-1.1/src/rfm12.h **** 		uint8_t checksum;
 153:../auxiliary/rfm12-1.1/src/rfm12.h **** 		
 154:../auxiliary/rfm12-1.1/src/rfm12.h **** 		//! The actual receive buffer data
 155:../auxiliary/rfm12-1.1/src/rfm12.h **** 		uint8_t buffer[RFM12_RX_BUFFER_SIZE]; 
 156:../auxiliary/rfm12-1.1/src/rfm12.h **** 	} rf_rx_buffer_t;
 157:../auxiliary/rfm12-1.1/src/rfm12.h **** #endif /* !(RFM12_TRANSMIT_ONLY) */	
 158:../auxiliary/rfm12-1.1/src/rfm12.h ****  
 159:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 160:../auxiliary/rfm12-1.1/src/rfm12.h **** //! Control and status structure.
 161:../auxiliary/rfm12-1.1/src/rfm12.h **** /** This data structure keeps all control and some status related variables. \n
 162:../auxiliary/rfm12-1.1/src/rfm12.h **** * By using a central structure for all global variables, the compiler can
 163:../auxiliary/rfm12-1.1/src/rfm12.h **** * use smaller instructions and reduce the size of the binary.
 164:../auxiliary/rfm12-1.1/src/rfm12.h **** *
 165:../auxiliary/rfm12-1.1/src/rfm12.h **** * \note Some states are defined in the non-documented rfm12_core.h header file.
 166:../auxiliary/rfm12-1.1/src/rfm12.h **** * \see ISR(RFM12_INT_VECT, ISR_NOBLOCK), rfm12_tick() and ctrl
 167:../auxiliary/rfm12-1.1/src/rfm12.h **** */
 168:../auxiliary/rfm12-1.1/src/rfm12.h **** typedef struct
 169:../auxiliary/rfm12-1.1/src/rfm12.h **** {
 170:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//! This controls the library internal state machine.
 171:../auxiliary/rfm12-1.1/src/rfm12.h **** 	volatile uint8_t rfm12_state;
 172:../auxiliary/rfm12-1.1/src/rfm12.h **** 	
 173:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//! Transmit buffer status.
 174:../auxiliary/rfm12-1.1/src/rfm12.h **** 	/** \see \ref rxtx_states "States for rx and tx buffers" */
 175:../auxiliary/rfm12-1.1/src/rfm12.h **** 	volatile uint8_t txstate;
 176:../auxiliary/rfm12-1.1/src/rfm12.h **** 	
 177:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//! Number of bytes to transmit or receive.
 178:../auxiliary/rfm12-1.1/src/rfm12.h **** 	/** This refers to the overall data size, including header data and sync bytes. */
 179:../auxiliary/rfm12-1.1/src/rfm12.h **** 	uint8_t num_bytes;
 180:../auxiliary/rfm12-1.1/src/rfm12.h **** 	
 181:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//! Counter for the bytes we are transmitting or receiving at the moment.
 182:../auxiliary/rfm12-1.1/src/rfm12.h **** 	uint8_t bytecount;
 183:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 184:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//if receive mode is not disabled (default)
 185:../auxiliary/rfm12-1.1/src/rfm12.h **** 	#if !(RFM12_TRANSMIT_ONLY)	
 186:../auxiliary/rfm12-1.1/src/rfm12.h **** 		//! Points to the receive buffer that will be filled next.
 187:../auxiliary/rfm12-1.1/src/rfm12.h **** 		rf_rx_buffer_t * rf_buffer_in;
 188:../auxiliary/rfm12-1.1/src/rfm12.h **** 		
 189:../auxiliary/rfm12-1.1/src/rfm12.h **** 		//! Points to the receive buffer that will be returned for the next read.
 190:../auxiliary/rfm12-1.1/src/rfm12.h **** 		rf_rx_buffer_t * rf_buffer_out;
 191:../auxiliary/rfm12-1.1/src/rfm12.h **** 		
 192:../auxiliary/rfm12-1.1/src/rfm12.h **** 		//! the number of the currently used in receive buffer.
 193:../auxiliary/rfm12-1.1/src/rfm12.h **** 		uint8_t buffer_in_num;
 194:../auxiliary/rfm12-1.1/src/rfm12.h **** 		
 195:../auxiliary/rfm12-1.1/src/rfm12.h **** 		//! the number of the currently used out receive buffer.
 196:../auxiliary/rfm12-1.1/src/rfm12.h **** 		uint8_t buffer_out_num;
 197:../auxiliary/rfm12-1.1/src/rfm12.h **** 	#endif /* !(RFM12_TRANSMIT_ONLY) */
 198:../auxiliary/rfm12-1.1/src/rfm12.h **** 	
 199:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//wakeup timer feature
 200:../auxiliary/rfm12-1.1/src/rfm12.h **** 	#if RFM12_USE_WAKEUP_TIMER
 201:../auxiliary/rfm12-1.1/src/rfm12.h **** 		//! Power management shadow register.
 202:../auxiliary/rfm12-1.1/src/rfm12.h **** 		/** The wakeup timer feature needs to buffer the current power management state. */
 203:../auxiliary/rfm12-1.1/src/rfm12.h **** 		uint16_t pwrmgt_shadow;
 204:../auxiliary/rfm12-1.1/src/rfm12.h **** 	#endif /* RFM12_USE_WAKEUP_TIMER */
 205:../auxiliary/rfm12-1.1/src/rfm12.h **** 	
 206:../auxiliary/rfm12-1.1/src/rfm12.h **** 	#if RFM12_LOW_BATT_DETECTOR
 207:../auxiliary/rfm12-1.1/src/rfm12.h **** 		//! Low battery detector status.
 208:../auxiliary/rfm12-1.1/src/rfm12.h **** 		/** \see \ref batt_states "States for the low battery detection feature",
 209:../auxiliary/rfm12-1.1/src/rfm12.h **** 		* as well as rfm12_set_batt_detector() and rfm12_get_batt_status()
 210:../auxiliary/rfm12-1.1/src/rfm12.h **** 		*/
 211:../auxiliary/rfm12-1.1/src/rfm12.h **** 		uint8_t low_batt;
 212:../auxiliary/rfm12-1.1/src/rfm12.h **** 	#endif /* RFM12_LOW_BATT_DETECTOR */
 213:../auxiliary/rfm12-1.1/src/rfm12.h **** } rfm12_control_t;
 214:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 215:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 216:../auxiliary/rfm12-1.1/src/rfm12.h **** /************************
 217:../auxiliary/rfm12-1.1/src/rfm12.h ****  * GLOBALS
 218:../auxiliary/rfm12-1.1/src/rfm12.h ****  */
 219:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 220:../auxiliary/rfm12-1.1/src/rfm12.h **** //Buffer and status for the message to be transmitted
 221:../auxiliary/rfm12-1.1/src/rfm12.h **** extern rf_tx_buffer_t rf_tx_buffer;
 222:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 223:../auxiliary/rfm12-1.1/src/rfm12.h **** //if receive mode is not disabled (default)
 224:../auxiliary/rfm12-1.1/src/rfm12.h **** #if !(RFM12_TRANSMIT_ONLY)
 225:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//buffers for storing incoming transmissions
 226:../auxiliary/rfm12-1.1/src/rfm12.h **** 	extern rf_rx_buffer_t rf_rx_buffers[2];
 227:../auxiliary/rfm12-1.1/src/rfm12.h **** #endif /* !(RFM12_TRANSMIT_ONLY) */
 228:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 229:../auxiliary/rfm12-1.1/src/rfm12.h **** //the control struct
 230:../auxiliary/rfm12-1.1/src/rfm12.h **** extern rfm12_control_t ctrl;
 231:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 232:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 233:../auxiliary/rfm12-1.1/src/rfm12.h **** /************************
 234:../auxiliary/rfm12-1.1/src/rfm12.h ****  * INLINE FUNCTIONS
 235:../auxiliary/rfm12-1.1/src/rfm12.h ****  */
 236:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 237:../auxiliary/rfm12-1.1/src/rfm12.h **** //if receive mode is not disabled (default)
 238:../auxiliary/rfm12-1.1/src/rfm12.h **** #if !(RFM12_TRANSMIT_ONLY)
 239:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//! Inline function to return the rx buffer status byte.
 240:../auxiliary/rfm12-1.1/src/rfm12.h **** 	/** \returns STATUS_FREE or STATUS_COMPLETE
 241:../auxiliary/rfm12-1.1/src/rfm12.h **** 	* \see \ref rxtx_states "rx buffer states", rfm12_rx_len(), rfm12_rx_type(), rfm12_rx_buffer(), rf
 242:../auxiliary/rfm12-1.1/src/rfm12.h **** 	*/
 243:../auxiliary/rfm12-1.1/src/rfm12.h **** 	static inline uint8_t rfm12_rx_status(void)
 244:../auxiliary/rfm12-1.1/src/rfm12.h **** 	{
 245:../auxiliary/rfm12-1.1/src/rfm12.h **** 		return ctrl.rf_buffer_out->status;
 1171               	.LM164:
 1172 005c E091 0000 		lds r30,ctrl+6
 1173 0060 F091 0000 		lds r31,ctrl+6+1
 1174 0064 8081      		ld r24,Z
 1175               	.LBE35:
 1176               	.LBE34:
 1178               	.Ltext9:
 118:serial-link-transceiver.c **** 		if (rfm12_rx_status() == STATUS_COMPLETE)
 1180               	.LM165:
 1181 0066 8230      		cpi r24,lo8(2)
 1182 0068 01F0      		breq .L60
 1183               	.L54:
 134:serial-link-transceiver.c **** 		if (timeValue > 30)
 1185               	.LM166:
 1186 006a 8091 0000 		lds r24,timeValue
 1187 006e 9091 0000 		lds r25,timeValue+1
 1188 0072 A091 0000 		lds r26,timeValue+2
 1189 0076 B091 0000 		lds r27,timeValue+3
 1190 007a 4F97      		sbiw r24,31
 1191 007c A105      		cpc r26,__zero_reg__
 1192 007e B105      		cpc r27,__zero_reg__
 1193 0080 00F4      		brsh .L61
 138:serial-link-transceiver.c ****             rfm12_tx(sizeof(tv), 0, tv);
 139:serial-link-transceiver.c ****             timeValue = 0;
 140:serial-link-transceiver.c ****         }
 141:serial-link-transceiver.c **** 		rfm12_tick();
 1195               	.LM167:
 1196 0082 00D0      		rcall rfm12_tick
 1197               	.L62:
 1198               	.LBB37:
 1199               	.LBB36:
 1201               	.Ltext10:
 1203               	.LM168:
 1204 0084 E091 0000 		lds r30,ctrl+6
 1205 0088 F091 0000 		lds r31,ctrl+6+1
 1206 008c 8081      		ld r24,Z
 1207               	.LBE36:
 1208               	.LBE37:
 1210               	.Ltext11:
 118:serial-link-transceiver.c **** 		if (rfm12_rx_status() == STATUS_COMPLETE)
 1212               	.LM169:
 1213 008e 8230      		cpi r24,lo8(2)
 1214 0090 01F4      		brne .L54
 1215               	.L60:
 1216               	.LBB38:
 120:serial-link-transceiver.c **** 			uint8_t *bufcontents = rfm12_rx_buffer();
 1218               	.LM170:
 1219 0092 8F01      		movw r16,r30
 1220 0094 0C5F      		subi r16,-4
 1221 0096 1F4F      		sbci r17,-1
 122:serial-link-transceiver.c ****             sendch('A');
 1223               	.LM171:
 1224 0098 81E4      		ldi r24,lo8(65)
 1225 009a 00D0      		rcall sendch
 1226               	.LBB39:
 1227               	.LBB40:
 1229               	.Ltext12:
 246:../auxiliary/rfm12-1.1/src/rfm12.h **** 	}
 247:../auxiliary/rfm12-1.1/src/rfm12.h **** 
 248:../auxiliary/rfm12-1.1/src/rfm12.h **** 	//! Inline function to return the rx buffer length field.
 249:../auxiliary/rfm12-1.1/src/rfm12.h **** 	/** \returns The length of the data inside the buffer
 250:../auxiliary/rfm12-1.1/src/rfm12.h **** 	* \see rfm12_rx_status(), rfm12_rx_type(), rfm12_rx_buffer(), rfm12_rx_clear() and rf_rx_buffer_t
 251:../auxiliary/rfm12-1.1/src/rfm12.h **** 	*/
 252:../auxiliary/rfm12-1.1/src/rfm12.h **** 	static inline uint8_t rfm12_rx_len(void)
 253:../auxiliary/rfm12-1.1/src/rfm12.h **** 	{
 254:../auxiliary/rfm12-1.1/src/rfm12.h **** 		return ctrl.rf_buffer_out->len;
 1231               	.LM172:
 1232 009c E091 0000 		lds r30,ctrl+6
 1233 00a0 F091 0000 		lds r31,ctrl+6+1
 1234               	.LBE40:
 1235               	.LBE39:
 1237               	.Ltext13:
 125:serial-link-transceiver.c **** 			for (i=0;i<rfm12_rx_len();i++)
 1239               	.LM173:
 1240 00a4 8181      		ldd r24,Z+1
 1241 00a6 8823      		tst r24
 1242 00a8 01F0      		breq .L56
 1243 00aa F12C      		mov r15,__zero_reg__
 1244               	.L57:
 127:serial-link-transceiver.c **** 				sendch(bufcontents[i]);
 1246               	.LM174:
 1247 00ac F801      		movw r30,r16
 1248 00ae EF0D      		add r30,r15
 1249 00b0 F11D      		adc r31,__zero_reg__
 1250 00b2 8081      		ld r24,Z
 1251 00b4 00D0      		rcall sendch
 125:serial-link-transceiver.c **** 			for (i=0;i<rfm12_rx_len();i++)
 1253               	.LM175:
 1254 00b6 F394      		inc r15
 1255               	.LBB42:
 1256               	.LBB41:
 1258               	.Ltext14:
 1260               	.LM176:
 1261 00b8 E091 0000 		lds r30,ctrl+6
 1262 00bc F091 0000 		lds r31,ctrl+6+1
 1263               	.LBE41:
 1264               	.LBE42:
 1266               	.Ltext15:
 125:serial-link-transceiver.c **** 			for (i=0;i<rfm12_rx_len();i++)
 1268               	.LM177:
 1269 00c0 8181      		ldd r24,Z+1
 1270 00c2 F816      		cp r15,r24
 1271 00c4 00F0      		brlo .L57
 1272               	.L56:
 131:serial-link-transceiver.c **** 			rfm12_rx_clear();
 1274               	.LM178:
 1275 00c6 00D0      		rcall rfm12_rx_clear
 1276 00c8 00C0      		rjmp .L54
 1277               	.L61:
 1278               	.LBE38:
 1279               	.LBB43:
 136:serial-link-transceiver.c ****             sendch('X');
 1281               	.LM179:
 1282 00ca 88E5      		ldi r24,lo8(88)
 1283 00cc 00D0      		rcall sendch
 137:serial-link-transceiver.c ****         	uint8_t tv[] = "444444";
 1285               	.LM180:
 1286 00ce E0E0      		ldi r30,lo8(.LC0)
 1287 00d0 F0E0      		ldi r31,hi8(.LC0)
 1288 00d2 DE01      		movw r26,r28
 1289 00d4 1196      		adiw r26,1
 1290 00d6 8E2D      		mov r24,r14
 1291               		0:
 1292 00d8 0190      		ld r0,Z+
 1293 00da 0D92      		st X+,r0
 1294 00dc 8A95      		dec r24
 1295 00de 01F4      		brne 0b
 138:serial-link-transceiver.c ****             rfm12_tx(sizeof(tv), 0, tv);
 1297               	.LM181:
 1298 00e0 AE01      		movw r20,r28
 1299 00e2 4F5F      		subi r20,-1
 1300 00e4 5F4F      		sbci r21,-1
 1301 00e6 60E0      		ldi r22,0
 1302 00e8 87E0      		ldi r24,lo8(7)
 1303 00ea 00D0      		rcall rfm12_tx
 139:serial-link-transceiver.c ****             timeValue = 0;
 1305               	.LM182:
 1306 00ec 1092 0000 		sts timeValue,__zero_reg__
 1307 00f0 1092 0000 		sts timeValue+1,__zero_reg__
 1308 00f4 1092 0000 		sts timeValue+2,__zero_reg__
 1309 00f8 1092 0000 		sts timeValue+3,__zero_reg__
 1310               	.LBE43:
 1312               	.LM183:
 1313 00fc 00D0      		rcall rfm12_tick
 1314 00fe 00C0      		rjmp .L62
 1326               	.Lscope14:
 1328               		.stabd	78,0,0
 1329               		.text
 1331               	.global	hardwareInit
 1333               	hardwareInit:
 1334               		.stabd	46,0,0
 142:serial-link-transceiver.c ****     }
 143:serial-link-transceiver.c **** }
 144:serial-link-transceiver.c **** 
 145:serial-link-transceiver.c **** /****************************************************************************/
 146:serial-link-transceiver.c **** /** @brief Initialize the hardware
 147:serial-link-transceiver.c **** 
 148:serial-link-transceiver.c **** */
 149:serial-link-transceiver.c **** 
 150:serial-link-transceiver.c **** void hardwareInit(void)
 151:serial-link-transceiver.c **** {
 1336               	.LM184:
 1337               	.LFBB15:
 1338               	/* prologue: function */
 1339               	/* frame size = 0 */
 1340               	/* stack size = 0 */
 1341               	.L__stack_usage = 0
 1342 037e 0895      		ret
 1344               	.Lscope15:
 1346               		.stabd	78,0,0
 1348               	.global	wdtInit
 1350               	wdtInit:
 1351               		.stabd	46,0,0
 152:serial-link-transceiver.c **** }
 153:serial-link-transceiver.c **** 
 154:serial-link-transceiver.c **** /****************************************************************************/
 155:serial-link-transceiver.c **** /** @brief Initialize the watchdog timer to interrupt on maximum delay
 156:serial-link-transceiver.c **** 
 157:serial-link-transceiver.c **** */
 158:serial-link-transceiver.c **** void wdtInit(void)
 159:serial-link-transceiver.c **** {
 1353               	.LM185:
 1354               	.LFBB16:
 1355               	/* prologue: function */
 1356               	/* frame size = 0 */
 1357               	/* stack size = 0 */
 1358               	.L__stack_usage = 0
 160:serial-link-transceiver.c **** /* Initialize the Watchdog timer to interrupt. */
 161:serial-link-transceiver.c **** /* IMPORTANT: Disable the "WDT Always On" fuse so that WDT can be turned off. */
 162:serial-link-transceiver.c ****     wdt_disable();     /* watchdog timer turn off ready for setup. */
 1360               	.LM186:
 1361 0380 88E1      		ldi r24,lo8(24)
 1362               	/* #APP */
 1363               	 ;  162 "serial-link-transceiver.c" 1
 1364 0382 0FB6      		in __tmp_reg__, __SREG__
 1365 0384 F894      		cli
 1366 0386 8093 6000 		sts 96, r24
 1367 038a 1092 6000 		sts 96, __zero_reg__
 1368 038e 0FBE      		out __SREG__,__tmp_reg__
 1369               		
 1370               	 ;  0 "" 2
 163:serial-link-transceiver.c ****     outb(WDTCR,0);
 1372               	.LM187:
 1373               	/* #NOAPP */
 1374 0390 1092 6000 		sts 96,__zero_reg__
 164:serial-link-transceiver.c **** /* Set the WDT with WDE clear, interrupts enabled, interrupt mode set, and
 165:serial-link-transceiver.c **** maximum timeout 8 seconds to give continuous interrupt mode. */
 166:serial-link-transceiver.c ****     sei();
 1376               	.LM188:
 1377               	/* #APP */
 1378               	 ;  166 "serial-link-transceiver.c" 1
 1379 0394 7894      		sei
 1380               	 ;  0 "" 2
 167:serial-link-transceiver.c **** //    outb(WDTCR,_BV(WDIE)|_BV(WDP3)|_BV(WDP0));
 168:serial-link-transceiver.c ****     outb(WDTCR,_BV(WDIE));  /* For test only: 32 ms timeout */
 1382               	.LM189:
 1383               	/* #NOAPP */
 1384 0396 80E4      		ldi r24,lo8(64)
 1385 0398 8093 6000 		sts 96,r24
 1386 039c 0895      		ret
 1388               	.Lscope16:
 1390               		.stabd	78,0,0
 1392               	.global	__vector_16
 1394               	__vector_16:
 1395               		.stabd	46,0,0
 169:serial-link-transceiver.c **** 
 170:serial-link-transceiver.c **** }
 171:serial-link-transceiver.c **** 
 172:serial-link-transceiver.c **** /****************************************************************************/
 173:serial-link-transceiver.c **** /** @brief Interrupt on RTC timer overflow
 174:serial-link-transceiver.c **** 
 175:serial-link-transceiver.c **** This ISR simply updates the RTC.
 176:serial-link-transceiver.c **** */
 177:serial-link-transceiver.c **** ISR(TIMER_INTERRUPT)
 178:serial-link-transceiver.c **** {
 1397               	.LM190:
 1398               	.LFBB17:
 1399 039e 1F92      		push r1
 1400 03a0 0F92      		push r0
 1401 03a2 0FB6      		in r0,__SREG__
 1402 03a4 0F92      		push r0
 1403 03a6 1124      		clr __zero_reg__
 1404 03a8 8F93      		push r24
 1405 03aa 9F93      		push r25
 1406 03ac AF93      		push r26
 1407 03ae BF93      		push r27
 1408               	/* prologue: Signal */
 1409               	/* frame size = 0 */
 1410               	/* stack size = 7 */
 1411               	.L__stack_usage = 7
 179:serial-link-transceiver.c ****   timeValue++;
 1413               	.LM191:
 1414 03b0 8091 0000 		lds r24,timeValue
 1415 03b4 9091 0000 		lds r25,timeValue+1
 1416 03b8 A091 0000 		lds r26,timeValue+2
 1417 03bc B091 0000 		lds r27,timeValue+3
 1418 03c0 0196      		adiw r24,1
 1419 03c2 A11D      		adc r26,__zero_reg__
 1420 03c4 B11D      		adc r27,__zero_reg__
 1421 03c6 8093 0000 		sts timeValue,r24
 1422 03ca 9093 0000 		sts timeValue+1,r25
 1423 03ce A093 0000 		sts timeValue+2,r26
 1424 03d2 B093 0000 		sts timeValue+3,r27
 1425               	/* epilogue start */
 180:serial-link-transceiver.c **** }
 1427               	.LM192:
 1428 03d6 BF91      		pop r27
 1429 03d8 AF91      		pop r26
 1430 03da 9F91      		pop r25
 1431 03dc 8F91      		pop r24
 1432 03de 0F90      		pop r0
 1433 03e0 0FBE      		out __SREG__,r0
 1434 03e2 0F90      		pop r0
 1435 03e4 1F90      		pop r1
 1436 03e6 1895      		reti
 1438               	.Lscope17:
 1440               		.stabd	78,0,0
 1441               		.local	checksum.1849
 1442               		.comm	checksum.1849,1,1
 1443               		.comm	timeValue,4,1
 1444               		.comm	checkSum,1,1
 1445               		.comm	lastError,1,1
 1446               		.comm	uartInput,2,1
 1447               		.comm	ctrl,10,1
 1448               		.comm	rf_rx_buffers,68,1
 1449               		.comm	rf_tx_buffer,35,1
 1458               	.Letext0:
 1459               		.ident	"GCC: (GNU) 4.8.2"
 1460               	.global __do_copy_data
 1461               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 serial-link-transceiver.c
     /tmp/cc5UB7ae.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc5UB7ae.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc5UB7ae.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc5UB7ae.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc5UB7ae.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc5UB7ae.s:113    .text:0000000000000000 spi_data
     /tmp/cc5UB7ae.s:180    .text:0000000000000022 rfm12_data
     /tmp/cc5UB7ae.s:217    .text:0000000000000036 rfm12_read
     /tmp/cc5UB7ae.s:267    .text:0000000000000060 rfm12_read_int_flags_inline
     /tmp/cc5UB7ae.s:322    .text:0000000000000078 rfm12_data_inline
     /tmp/cc5UB7ae.s:365    .text:0000000000000098 rfm12_read_fifo_inline
     /tmp/cc5UB7ae.s:398    .text:00000000000000a6 spi_init
     /tmp/cc5UB7ae.s:427    .text:00000000000000b0 __vector_2
                            *COM*:000000000000000a ctrl
                             .bss:0000000000000000 checksum.1849
                            *COM*:0000000000000044 rf_rx_buffers
                            *COM*:0000000000000023 rf_tx_buffer
     /tmp/cc5UB7ae.s:671    .text:00000000000001fc rfm12_tick
     /tmp/cc5UB7ae.s:741    .text:0000000000000240 rfm12_start_tx
     /tmp/cc5UB7ae.s:791    .text:0000000000000266 rfm12_tx
     /tmp/cc5UB7ae.s:876    .text:00000000000002b8 rfm12_rx_clear
     /tmp/cc5UB7ae.s:922    .text:00000000000002e8 rfm12_init
     /tmp/cc5UB7ae.s:1075   .text.startup:0000000000000000 main
                            *COM*:0000000000000004 timeValue
     /tmp/cc5UB7ae.s:1333   .text:000000000000037e hardwareInit
     /tmp/cc5UB7ae.s:1350   .text:0000000000000380 wdtInit
     /tmp/cc5UB7ae.s:1394   .text:000000000000039e __vector_16
                            *COM*:0000000000000001 checkSum
                            *COM*:0000000000000001 lastError
                            *COM*:0000000000000002 uartInput

UNDEFINED SYMBOLS
memcpy
uartInit
timer0Init
sendch
__do_copy_data
__do_clear_bss
